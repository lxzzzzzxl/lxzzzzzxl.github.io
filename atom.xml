<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>霹雳大乌龙的学习笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxzzzzzxl.github.io/"/>
  <updated>2019-05-02T06:54:42.000Z</updated>
  <id>https://lxzzzzzxl.github.io/</id>
  
  <author>
    <name>霹雳大乌龙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RT-Thread学习笔记 —— 信号量</title>
    <link href="https://lxzzzzzxl.github.io/2019/05/02/RT-Thread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E2%80%94%E2%80%94%20%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>https://lxzzzzzxl.github.io/2019/05/02/RT-Thread学习笔记 —— 信号量/</id>
    <published>2019-05-02T06:12:00.000Z</published>
    <updated>2019-05-02T06:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号量控制块"><a href="#信号量控制块" class="headerlink" title="信号量控制块"></a>信号量控制块</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span></span><br><span class="line">    <span class="keyword">rt_unit16_t</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span>* <span class="title">rt_sem_t</span>;</span></span><br></pre></td></tr></table></figure><a id="more"></a>  <h2 id="信号量的管理方式"><a href="#信号量的管理方式" class="headerlink" title="信号量的管理方式"></a>信号量的管理方式</h2><p>信号量的相关接口如下：<br><a href="#head1"><code>rt_sem_create 创建信号量</code></a><br><a href="#head2"><code>rt_sem_delete 删除信号量</code></a><br><a href="#head3"><code>rt_sem_init 初始化信号量</code></a><br><a href="#head4"><code>rt_sem_detach 脱离信号量</code></a><br><a href="#head5"><code>rt_sem_take/trytake 获取信号量</code></a><br><a href="#head6"><code>rt_sem_release 释放信号量</code></a>  </p><p><a id="head1"></a></p><h2 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_sem_t</span> rt_sem_create(<span class="keyword">const</span> <span class="keyword">char</span> *name,           <span class="comment">//信号量名称</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> vaule,         <span class="comment">//信号量初始值</span></span><br><span class="line">                        <span class="keyword">rt_uint8_t</span> flag);          <span class="comment">//信号量标志</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回信号量控制块指针，失败返回RT_NULL</span><br><span class="line">-&gt;  flag可取值如下：</span><br><span class="line">    RT_IPC_FLAG_FIFO(先进先出)</span><br><span class="line">    RT_IPC_FLAG_PRIO(优先级等待)</span><br></pre></td></tr></table></figure><p><a id="head2"></a></p><h2 id="删除信号量"><a href="#删除信号量" class="headerlink" title="删除信号量"></a>删除信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_delete(<span class="keyword">rt_sem_t</span> sem);               <span class="comment">//信号量对象</span></span><br><span class="line"></span><br><span class="line">-&gt; 成功返回RT_EOK</span><br></pre></td></tr></table></figure><p><a id="head3"></a></p><h2 id="初始化信号量"><a href="#初始化信号量" class="headerlink" title="初始化信号量"></a>初始化信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_init(<span class="keyword">rt_sem_t</span> sem,              <span class="comment">//信号量对象句柄</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *name,       <span class="comment">//信号量名称</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> vaule,      <span class="comment">//信号量初始值</span></span><br><span class="line">                        <span class="keyword">rt_uint8_t</span> flag);       <span class="comment">//信号量标志</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK</span><br></pre></td></tr></table></figure><p><a id="head4"></a></p><h2 id="脱离信号量"><a href="#脱离信号量" class="headerlink" title="脱离信号量"></a>脱离信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_detach(<span class="keyword">rt_sem_t</span> sem);</span><br></pre></td></tr></table></figure><p><a id="head5"></a></p><h2 id="获取信号量"><a href="#获取信号量" class="headerlink" title="获取信号量"></a>获取信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_take(<span class="keyword">rt_sem_t</span> sem,              <span class="comment">//信号量对象句柄</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> time);      <span class="comment">//等待时间</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,超时返回-RT_ETIMEOUT,其他错误返回-RT_ERROR</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_trytake(<span class="keyword">rt_sem_t</span> sem);          <span class="comment">//无等待获取信号量</span></span><br></pre></td></tr></table></figure><p><a id="head6"></a></p><h2 id="释放信号量"><a href="#释放信号量" class="headerlink" title="释放信号量"></a>释放信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_release(<span class="keyword">rt_sem_t</span> sem);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信号量控制块&quot;&gt;&lt;a href=&quot;#信号量控制块&quot; class=&quot;headerlink&quot; title=&quot;信号量控制块&quot;&gt;&lt;/a&gt;信号量控制块&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rt_semaphore&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rt_ipc_object&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;parent&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;rt_unit16_t&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rt_semaphore&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;rt_sem_t&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="RT-Thread" scheme="https://lxzzzzzxl.github.io/categories/RT-Thread/"/>
    
    
      <category term="RT-thread" scheme="https://lxzzzzzxl.github.io/tags/RT-thread/"/>
    
      <category term="线程同步" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="信号量" scheme="https://lxzzzzzxl.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread学习笔记 —— UART串口</title>
    <link href="https://lxzzzzzxl.github.io/2019/04/28/RT-Thread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E2%80%94%E2%80%94%20UART%E4%B8%B2%E5%8F%A3/"/>
    <id>https://lxzzzzzxl.github.io/2019/04/28/RT-Thread学习笔记 —— UART串口/</id>
    <published>2019-04-28T08:43:00.000Z</published>
    <updated>2019-04-28T10:00:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问串口设备"><a href="#访问串口设备" class="headerlink" title="访问串口设备"></a>访问串口设备</h2><p>应用程序通过 RT-Thread提供的 I/O 设备管理接口来访问串口硬件，相关接口如下所示：  </p><a id="more"></a>  <p><a href="#head1"><code>rt_device_find()    查找设备</code></a><br><a href="#head2"><code>rt_device_open()    打开设备</code></a><br><a href="#head3"><code>rt_device_read()    读取数据</code></a><br><a href="#head4"><code>rt_device_write()    写入数据</code></a><br><a href="#head5"><code>rt_device_control()    控制设备</code></a><br><a href="#head6"><code>rt_device_set_rx_indicate()    设置接收回调函数</code></a><br><a href="#head7"><code>rt_device_set_tx_complete()    设置发送完成回调函数</code></a><br><a href="#head8"><code>rt_device_close()    关闭设备</code></a></p><p><a id="head1"></a></p><h2 id="查找串口设备"><a href="#查找串口设备" class="headerlink" title="查找串口设备"></a>查找串口设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_device_t</span> rt_device_find(</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">char</span>* name);              <span class="comment">//设备名称</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回设备句柄，失败返回RT_NULL</span><br></pre></td></tr></table></figure><p><a id="head2"></a></p><h2 id="打开设备"><a href="#打开设备" class="headerlink" title="打开设备"></a>打开设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_open(<span class="keyword">rt_device_t</span> dev,                    <span class="comment">//设备句柄</span></span><br><span class="line">                        <span class="keyword">rt_uint16_t</span> oflags);                <span class="comment">//设备访问模式标志</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_EBUSY(或其他错误代码)</span><br><span class="line">-&gt;  oflags支持以下参数：</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_CLOSE                   <span class="comment">//设备已经关闭</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_RDONLY                  <span class="comment">//以只读方式打开设备</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_WRONLY                  <span class="comment">//以只写方式打开设备</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_RDWR                    <span class="comment">//以读写方式打开设备</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_OPEN                    <span class="comment">//设备已经打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_STREAM                   <span class="comment">//设备以流模式打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_INT_RX                   <span class="comment">//设备以中断接收模式打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_DMA_RX                   <span class="comment">//设备以DMA接收模式打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_INT_TX                   <span class="comment">//设备以中断发送模式打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_DMA_TX                   <span class="comment">//设备以DMA发送模式打开</span></span></span><br></pre></td></tr></table></figure><p><a id="head3"></a></p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_size_t</span> rt_device_read(<span class="keyword">rt_device_t</span> dev,           <span class="comment">//设备句柄</span></span><br><span class="line">                         <span class="keyword">rt_off_t</span> pos,              <span class="comment">//读取数据偏移量</span></span><br><span class="line">                         <span class="keyword">void</span>* buffer,              <span class="comment">//内存缓冲区指针</span></span><br><span class="line">                         <span class="keyword">rt_size_t</span> size);           <span class="comment">//读取数据的大小</span></span><br><span class="line"></span><br><span class="line">-&gt;  返回读到数据的实际大小</span><br></pre></td></tr></table></figure><p><a id="head4"></a></p><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_size_t</span> rt_device_write(<span class="keyword">rt_device_t</span> dev,          <span class="comment">//设备句柄</span></span><br><span class="line">                          <span class="keyword">rt_off_t</span> pos,             <span class="comment">//写入数据偏移量</span></span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">void</span>* buffer,       <span class="comment">//内存缓冲区</span></span><br><span class="line">                          <span class="keyword">rt_size_t</span> size);          <span class="comment">//写入数据的大小</span></span><br><span class="line"></span><br><span class="line">-&gt;  返回写入数据的实际大小</span><br></pre></td></tr></table></figure><p><a id="head5"></a></p><h2 id="控制设备"><a href="#控制设备" class="headerlink" title="控制设备"></a>控制设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_control(<span class="keyword">rt_device_t</span> dev,         <span class="comment">//设备句柄</span></span><br><span class="line">                            <span class="keyword">rt_uint8_t</span> cmd,         <span class="comment">//控制命令</span></span><br><span class="line">                            <span class="keyword">void</span>* arg);             <span class="comment">//控制参数</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ENOSYS(或其他错误代码)</span><br></pre></td></tr></table></figure><p><a id="head6"></a></p><h2 id="设置接收回调函数"><a href="#设置接收回调函数" class="headerlink" title="设置接收回调函数"></a>设置接收回调函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_set_rx_indicate(<span class="keyword">rt_device_t</span> dev,             <span class="comment">//设备句柄</span></span><br><span class="line">    <span class="keyword">rt_err_t</span> (*rx_ind)(<span class="keyword">rt_device_t</span> dev, <span class="keyword">rt_size_t</span> size));       <span class="comment">//回调函数指针</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK</span><br></pre></td></tr></table></figure><p><a id="head7"></a></p><h2 id="设置发送完成回调函数"><a href="#设置发送完成回调函数" class="headerlink" title="设置发送完成回调函数"></a>设置发送完成回调函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_set_tx_complete(<span class="keyword">rt_device_t</span> dev,             <span class="comment">//设备句柄</span></span><br><span class="line">    <span class="keyword">rt_err_t</span> (*tx_done)(<span class="keyword">rt_device_t</span> dev, <span class="keyword">void</span> *buffer));        <span class="comment">//回调函数指针</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK</span><br></pre></td></tr></table></figure><p><a id="head8"></a></p><h2 id="关闭设备"><a href="#关闭设备" class="headerlink" title="关闭设备"></a>关闭设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_close(<span class="keyword">rt_device_t</span> dev);              <span class="comment">//设备句柄</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR(或其他错误码)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;访问串口设备&quot;&gt;&lt;a href=&quot;#访问串口设备&quot; class=&quot;headerlink&quot; title=&quot;访问串口设备&quot;&gt;&lt;/a&gt;访问串口设备&lt;/h2&gt;&lt;p&gt;应用程序通过 RT-Thread提供的 I/O 设备管理接口来访问串口硬件，相关接口如下所示：  &lt;/p&gt;
    
    </summary>
    
      <category term="RT-Thread" scheme="https://lxzzzzzxl.github.io/categories/RT-Thread/"/>
    
    
      <category term="RT-thread" scheme="https://lxzzzzzxl.github.io/tags/RT-thread/"/>
    
      <category term="UART串口" scheme="https://lxzzzzzxl.github.io/tags/UART%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread学习笔记 —— 线程管理</title>
    <link href="https://lxzzzzzxl.github.io/2019/04/28/RT-Thread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%20%E2%80%94%E2%80%94%20%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://lxzzzzzxl.github.io/2019/04/28/RT-Thread学习笔记  —— 线程管理/</id>
    <published>2019-04-28T04:19:00.000Z</published>
    <updated>2019-04-28T04:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和删除线程（动态线程）"><a href="#创建和删除线程（动态线程）" class="headerlink" title="创建和删除线程（动态线程）"></a>创建和删除线程（动态线程）</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_thread_t</span> rt_thread_create(<span class="keyword">const</span> <span class="keyword">char</span>* name,                  <span class="comment">//线程名称</span></span><br><span class="line">                            <span class="keyword">void</span> (*entry) (<span class="keyword">void</span>* parameter),    <span class="comment">//线程入口函数</span></span><br><span class="line">                            <span class="keyword">void</span>* parameter,                    <span class="comment">//线程入口函数参数</span></span><br><span class="line">                            <span class="keyword">rt_uint32_t</span> stack_size,             <span class="comment">//线程栈大小，单位是字节</span></span><br><span class="line">                            <span class="keyword">rt_uint8_t</span> priority,                <span class="comment">//线程优先级</span></span><br><span class="line">                            <span class="keyword">rt_uint32_t</span> tick);                  <span class="comment">//线程时间片大小</span></span><br><span class="line"></span><br><span class="line">-&gt;  线程创建成功返回线程句柄，失败返回RT_NULL</span><br></pre></td></tr></table></figure><h3 id="删除线程"><a href="#删除线程" class="headerlink" title="删除线程"></a>删除线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_delete(</span><br><span class="line">                            <span class="keyword">rt_thread_t</span> thread                  <span class="comment">//要删除的线程句柄</span></span><br><span class="line">                            );</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><a id="more"></a>  <h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_PRIORITY         25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_STACK_SIZE512    512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_TIMESLICE        5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread1_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">"thread1 count: %d\n"</span>, count ++);</span><br><span class="line">        rt_thread_mdelay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thread_sample</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tid1 = rt_thread_create(<span class="string">"thread1"</span>,</span><br><span class="line">                            thread1_entry,</span><br><span class="line">                            RT_NULL,</span><br><span class="line">                            THREAD_STACK_SIZE,</span><br><span class="line">                            THREAD_PRIORITY,</span><br><span class="line">                            THREAD_TIMESLICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL)</span><br><span class="line">        rt_thread_startup(tid1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化和脱离线程（静态线程）"><a href="#初始化和脱离线程（静态线程）" class="headerlink" title="初始化和脱离线程（静态线程）"></a>初始化和脱离线程（静态线程）</h2><h3 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_init(struct rt_thread* thread,               <span class="comment">//线程句柄</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span>* name,                       <span class="comment">//线程名称</span></span><br><span class="line">                        <span class="keyword">void</span> (*entry) (<span class="keyword">void</span>* parameter),        <span class="comment">//线程入口函数</span></span><br><span class="line">                        <span class="keyword">void</span>* parameter,                        <span class="comment">//线程入口函数参数</span></span><br><span class="line">                        <span class="keyword">void</span>* stack_start,                      <span class="comment">//线程栈起始地址</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> stack_size,                 <span class="comment">//线程栈大小</span></span><br><span class="line">                        <span class="keyword">rt_uint8_t</span> priority,                    <span class="comment">//线程优先级</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> tick);                      <span class="comment">//线程时间片大小</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h3 id="脱离线程"><a href="#脱离线程" class="headerlink" title="脱离线程"></a>脱离线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_detach(</span><br><span class="line">                            <span class="keyword">rt_thread_t</span> thread                  <span class="comment">//要脱离的线程句柄</span></span><br><span class="line">                            );</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_PRIORITY         25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_STACK_SIZE512    512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_TIMESLICE        5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> <span class="title">thread2</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> thread2_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread2_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">"thread1 count: %d\n"</span>, count ++);</span><br><span class="line">        rt_thread_mdelay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thread_sample</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt_thread_init(&amp;thread2,</span><br><span class="line">                    <span class="string">"thread2"</span>,</span><br><span class="line">                    thread2_entry,</span><br><span class="line">                    RT_NULL,</span><br><span class="line">                    &amp;thread2_stack[<span class="number">0</span>],</span><br><span class="line">                    <span class="keyword">sizeof</span>(thread2_stack),</span><br><span class="line">                    THREAD_PRIORITY,</span><br><span class="line">                    THREAD_TIMESLICE);</span><br><span class="line">    </span><br><span class="line">    rt_thread_startup(&amp;thread2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_startup(<span class="keyword">rt_thread_t</span> thread);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h2 id="获得当前线程"><a href="#获得当前线程" class="headerlink" title="获得当前线程"></a>获得当前线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_thread_t</span> rt_thread_self(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回当前运行的线程句柄，失败返回RT_NULL(调度器未启动)</span><br></pre></td></tr></table></figure><h2 id="使线程让出处理器资源"><a href="#使线程让出处理器资源" class="headerlink" title="使线程让出处理器资源"></a>使线程让出处理器资源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_yield(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">rt_schedule()</span><br></pre></td></tr></table></figure><h2 id="使线程睡眠"><a href="#使线程睡眠" class="headerlink" title="使线程睡眠"></a>使线程睡眠</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_sleep(<span class="keyword">rt_tick_t</span> tick);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_delay(<span class="keyword">rt_tick_t</span> tick);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_mdelay(<span class="keyword">rt_uint32_t</span> ms);</span><br></pre></td></tr></table></figure><h2 id="挂起和恢复线程"><a href="#挂起和恢复线程" class="headerlink" title="挂起和恢复线程"></a>挂起和恢复线程</h2><h3 id="挂起线程"><a href="#挂起线程" class="headerlink" title="挂起线程"></a>挂起线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_suspend(<span class="keyword">rt_thread_t</span> thread);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h3 id="恢复线程"><a href="#恢复线程" class="headerlink" title="恢复线程"></a>恢复线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_resume(<span class="keyword">rt_thread_t</span> thread);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_control(<span class="keyword">rt_thread_t</span> thread,              <span class="comment">//线程句柄</span></span><br><span class="line">                            <span class="keyword">rt_uint8_t</span> cmd,                 <span class="comment">//控制命令</span></span><br><span class="line">                             <span class="keyword">void</span>* arg);                    <span class="comment">//控制参数</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br><span class="line"></span><br><span class="line">支持如下cmd命令：</span><br><span class="line">                RT_THREAD_CTRL_CHANGE_PRIORITY              <span class="comment">//动态更改线程优先级</span></span><br><span class="line">                RT_THREAD_CTRL_STARTUP                      <span class="comment">//开始运行一个线程</span></span><br><span class="line">                RT_THREAD_CTRL_CLOSE                        <span class="comment">//关闭一个线程</span></span><br></pre></td></tr></table></figure><h2 id="设置和删除空闲钩子"><a href="#设置和删除空闲钩子" class="headerlink" title="设置和删除空闲钩子"></a>设置和删除空闲钩子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_idle_sethook(<span class="keyword">void</span> (*hook)(<span class="keyword">void</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_idle_delhook(<span class="keyword">void</span> (*hook)(<span class="keyword">void</span>));</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_EFULL</span><br><span class="line">-&gt;  hook:设置的钩子函数</span><br></pre></td></tr></table></figure><h2 id="设置调度器钩子"><a href="#设置调度器钩子" class="headerlink" title="设置调度器钩子"></a>设置调度器钩子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_scheduler_sethook</span><span class="params">(<span class="keyword">void</span> (*hook)(struct rt_thread* from, struct rt_thread* to))</span></span>;</span><br><span class="line"></span><br><span class="line">-&gt;  钩子函数声明如下：</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">(struct rt_thread* from, struct rt_thread* to)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建和删除线程（动态线程）&quot;&gt;&lt;a href=&quot;#创建和删除线程（动态线程）&quot; class=&quot;headerlink&quot; title=&quot;创建和删除线程（动态线程）&quot;&gt;&lt;/a&gt;创建和删除线程（动态线程）&lt;/h2&gt;&lt;h3 id=&quot;创建线程&quot;&gt;&lt;a href=&quot;#创建线程&quot; class=&quot;headerlink&quot; title=&quot;创建线程&quot;&gt;&lt;/a&gt;创建线程&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;rt_thread_t&lt;/span&gt; rt_thread_create(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* name,                  &lt;span class=&quot;comment&quot;&gt;//线程名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*entry) (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* parameter),    &lt;span class=&quot;comment&quot;&gt;//线程入口函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* parameter,                    &lt;span class=&quot;comment&quot;&gt;//线程入口函数参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;rt_uint32_t&lt;/span&gt; stack_size,             &lt;span class=&quot;comment&quot;&gt;//线程栈大小，单位是字节&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;rt_uint8_t&lt;/span&gt; priority,                &lt;span class=&quot;comment&quot;&gt;//线程优先级&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;rt_uint32_t&lt;/span&gt; tick);                  &lt;span class=&quot;comment&quot;&gt;//线程时间片大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt;  线程创建成功返回线程句柄，失败返回RT_NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;删除线程&quot;&gt;&lt;a href=&quot;#删除线程&quot; class=&quot;headerlink&quot; title=&quot;删除线程&quot;&gt;&lt;/a&gt;删除线程&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;rt_err_t&lt;/span&gt; rt_thread_delete(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;rt_thread_t&lt;/span&gt; thread                  &lt;span class=&quot;comment&quot;&gt;//要删除的线程句柄&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt;  成功返回RT_EOK,失败返回-RT_ERROR&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="RT-Thread" scheme="https://lxzzzzzxl.github.io/categories/RT-Thread/"/>
    
    
      <category term="RT-thread" scheme="https://lxzzzzzxl.github.io/tags/RT-thread/"/>
    
      <category term="线程管理" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(C语言) —— 队列</title>
    <link href="https://lxzzzzzxl.github.io/2019/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(C%E8%AF%AD%E8%A8%80)%20%E2%80%94%E2%80%94%20%E9%98%9F%E5%88%97/"/>
    <id>https://lxzzzzzxl.github.io/2019/04/12/数据结构(C语言) —— 队列/</id>
    <published>2019-04-12T12:27:19.000Z</published>
    <updated>2019-04-14T02:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h1><p>队列也是一种特殊的线性表，队列的数据元素及数据元素间的逻辑关系和线性表完全相同；其差别在于，线性表允许在任意位置插入和删除数据元素，而队列只允许在其一端进行插入操作，在另一端进行删除操作；进行插入操作的一端称为队尾，允许删除操作的一端称为队头。队列是一种先进先出的线性表。</p><a id="more"></a>  <h2 id="顺序循环队列的表示和实现"><a href="#顺序循环队列的表示和实现" class="headerlink" title="顺序循环队列的表示和实现"></a>顺序循环队列的表示和实现</h2><h3 id="顺序循环队列的结构体定义如下："><a href="#顺序循环队列的结构体定义如下：" class="headerlink" title="顺序循环队列的结构体定义如下："></a>顺序循环队列的结构体定义如下：</h3><pre><code>typedef struct{    DataType queue[MaxQueueSize];    int rear;                //队尾指针    int front;               //队头指针    int count;             //计数器}SeqCQueue;</code></pre><h3 id="顺序循环队列的算法实现如下："><a href="#顺序循环队列的算法实现如下：" class="headerlink" title="顺序循环队列的算法实现如下："></a>顺序循环队列的算法实现如下：</h3><p>1.初始化</p><pre><code>void QueueInitiate(SeqCQueue *Q){    Q-&gt;rear = 0;    Q-&gt;front = 0;    Q-&gt;count = 0;}</code></pre><p>2.判断非空否</p><pre><code>int QueueNotEmpty(SeqCQueue Q){    if(Q.count != 0) return 1;    else return 0;}</code></pre><p>3.入队列</p><pre><code>QueueAppend(SeqCQueue *Q, DataType x){    if(Q-&gt;count &gt; 0 &amp;&amp; Q-&gt;rear == Q-&gt;front)    {        printf(&quot;队列已满无法插入！&quot;);        return 0;    }    else    {        Q-&gt;queue[Q-&gt;rear] = x;        Q-&gt;rear = (Q-&gt;rear + 1) % MaxQueueSize;        Q-&gt;count ++;        return 1;    }}</code></pre><p>4.出队列</p><pre><code>QueueDelete(SeqCQueue *Q, DataType *d){    if(Q-&gt;count == 0)    {        printf(&quot;队列已空！&quot;);        return 0;    }    else    {        *d = Q-&gt;queue[Q-&gt;front];        Q-&gt;front = (Q-&gt;front + 1) % MaxQueueSize;        Q-&gt;count --;        return 1;    }}</code></pre><p>5.取队头数据元素</p><pre><code>int QueueGet(SeqCQueue Q, DataType *d){    if(Q.count == 0)    {        printf(&quot;队列已空！&quot;);        return 0；    }    else    {        *d = Q.queue[Q.front];        return 1;    }}</code></pre><h2 id="链式队列的表示和实现"><a href="#链式队列的表示和实现" class="headerlink" title="链式队列的表示和实现"></a>链式队列的表示和实现</h2><h3 id="链式队列的存储结构"><a href="#链式队列的存储结构" class="headerlink" title="链式队列的存储结构"></a>链式队列的存储结构</h3><p> 链式队列中结点的结构体定义如下：</p><pre><code>typedef struct qnode{    DataType data;    struct qnode *next;}LQNode;</code></pre><p> 定义链式队列的队头指针front和队尾指针rear的结构体如下：</p><pre><code>typedef struct{    LQNode *front;    LQNode *rear;}LQueue;                   //可看做初始队列</code></pre><h3 id="链式队列操作的实现"><a href="#链式队列操作的实现" class="headerlink" title="链式队列操作的实现"></a>链式队列操作的实现</h3><p>1.初始化  </p><pre><code>void QueueInitiate(LQueue *Q){    Q-&gt;rear = NULL;    Q-&gt;front = NULL;}</code></pre><p>2.判断非空否  </p><pre><code>int QueueNotEmpty(LQueue Q){    if(Q.front == NULL) return 0;    else return 1;}</code></pre><p>3.入队列  </p><pre><code>void QueueAppend(LQueue *Q, DataType x){    LQNode *p;    p = (LQNode *)malloc(sizeof(LQNode));    p-&gt;data = x;    p-&gt;next = NULL;    if(Q-&gt;rear != NULL) Q-&gt;rear-&gt;next = p;  //队列原本非空时，队尾加新节点    Q-&gt;rear = p;                            //修改队尾指针    if(Q-&gt;front == NULL) Q-&gt;front = p;      //队列原本为空时，修改队头指针}</code></pre><p>4.出队列  </p><pre><code>int QueueDelete(LQueue *Q, DataType *d){    LQNode *p;    if(Q-&gt;front == NULL)    {        printf(&quot;队列已空！&quot;);        return 0;    }    else    {        *d = Q-&gt;front-&gt;data;        p = Q-&gt;front;        Q-&gt;front = Q-&gt;front-&gt;next;        if(Q-&gt;front == NULL) Q-&gt;rear = NULL;    //删除最后一个结点后，要置队尾指针为空        free(p);        return 1;    }}</code></pre><p>5.取队头数据元素  </p><pre><code>int QueueGet(LQueue Q, DataType *d){    if(Q.front == NULL)    {        printf(&quot;队列已空！&quot;);        return 0;    }    else    {        *d = Q.front-&gt;data;        return 1;    }}</code></pre><p>6.撤销动态申请空间  </p><pre><code>void Destory(LQueue Q){    LQNode *p, *p1;    p = Q.front;    while(p != NULL)    {        p1 = p;        p = p-&gt;next;        free(p1);    }}</code></pre><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列与一般队列的主要区别是：优先级队列的出队操作不是把队头元素出队列，而是把队列中优先级最高的数据元素出队列。</p><h3 id="顺序优先级队列的设计和实现"><a href="#顺序优先级队列的设计和实现" class="headerlink" title="顺序优先级队列的设计和实现"></a>顺序优先级队列的设计和实现</h3><p>优先级队列的数据元素的结构体定义如下：</p><pre><code>typedef struct{    int priority;           //优先级     ElemType elem;      //其他内容} DataType;</code></pre><p>优先级队列的结构体定义如下：</p><pre><code>typedef struct{    DataType queue[MaxQueueSize];    int size;} SeqPQueue;</code></pre><p>1.初始化</p><pre><code>void QueueInitiate(SeqPQueue *Q){    Q-&gt;size = 0;}</code></pre><p>2.判断非空否</p><pre><code>int QueueNotEmpty(SeqPQueue Q){    if(Q.size &lt;= 0) return 0;    else return 1;}</code></pre><p>3.入队列</p><pre><code>int QueueAppend(SeqPQueue *Q, DataType x){    if(Q-&gt;size &gt;=MaxQueueSize)    {        printf(“队列已满！”);        return 0;    }    else    {        Q-&gt;queue[Q-&gt;size] = x;        Q-&gt;size++;        return 1;    }}</code></pre><p>4.出队列</p><pre><code>int QueueDelete(SeqPQueue *Q, DataType *d){    DataType min;    int minIndex, i;    if(Q-&gt;size &lt;= 0)    {        printf(“队列已空！”);        return 0;    }    else    {        min = Q-&gt;queue[0];      //初始queue[0]为优先级最高元素        minIndex = 0;               //minIndex为优先级最高元素下标        for(i=0; i&lt;Q-&gt;size; i++)    //寻找优先级最高元素对应下标            if(Q-&gt;queue[i].priority &lt;min.priority)            {                min = Q-&gt;queue[i];                minIndex = i;            }            *d = Q-&gt;queue[minIndex];        //找到优先级最高元素            for(i=minIndex+1; i&lt;Q-&gt;size; i++) //数据元素依次前移                Q-&gt;queue[i-1] = q-&gt;queue[i];            Q-&gt;size --;            return 1;    }}</code></pre><p>5.取队列优先级最高元素</p><pre><code>int QueueGet(SeqPQueue *Q, DataType x){    DataType min;    int minIndex, i;    if(Q-&gt;size &lt;= 0)    {        printf(“队列已空！”);        return 0;    }    else    {        min = Q-&gt;queue[0];        minIndex = 0;        for(i=1; i&lt;Q-&gt;size; i++)            if(Q-&gt;queue[i].priority &lt; min.priority)            {                min = Q-&gt;queue[i];                minIndex = i;            }        *d = Q-&gt;queue[minIndex];        return 1;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;队列的基本概念&quot;&gt;&lt;a href=&quot;#队列的基本概念&quot; class=&quot;headerlink&quot; title=&quot;队列的基本概念&quot;&gt;&lt;/a&gt;队列的基本概念&lt;/h1&gt;&lt;p&gt;队列也是一种特殊的线性表，队列的数据元素及数据元素间的逻辑关系和线性表完全相同；其差别在于，线性表允许在任意位置插入和删除数据元素，而队列只允许在其一端进行插入操作，在另一端进行删除操作；进行插入操作的一端称为队尾，允许删除操作的一端称为队头。队列是一种先进先出的线性表。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="https://lxzzzzzxl.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(C语言) —— 堆栈</title>
    <link href="https://lxzzzzzxl.github.io/2019/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(C%E8%AF%AD%E8%A8%80)%20%E2%80%94%E2%80%94%20%E5%A0%86%E6%A0%88/"/>
    <id>https://lxzzzzzxl.github.io/2019/04/10/数据结构(C语言) —— 堆栈/</id>
    <published>2019-04-10T08:24:19.000Z</published>
    <updated>2019-04-10T09:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆栈的基本概念"><a href="#堆栈的基本概念" class="headerlink" title="堆栈的基本概念"></a>堆栈的基本概念</h1><p> 堆栈是一种特殊的线性表，其数据元素以及数据元素间的逻辑关系和线性表的完全相同，其差别是：线性表允许在任意位置插入和删除数据元素，而堆栈只允许在固定一端进行插入和删除数据元素操作。<br> 堆栈中允许进行插入和删除操作的一端成为栈顶，另一端成为栈底；最后进入堆栈的数据元素总是最先退出堆栈，因此堆栈也称作后进先出的线性表。</p><a id="more"></a>  <h1 id="堆栈的顺序表示和实现（顺序堆栈）"><a href="#堆栈的顺序表示和实现（顺序堆栈）" class="headerlink" title="堆栈的顺序表示和实现（顺序堆栈）"></a>堆栈的顺序表示和实现（顺序堆栈）</h1><h2 id="1-顺序堆栈的存储结构"><a href="#1-顺序堆栈的存储结构" class="headerlink" title="1.顺序堆栈的存储结构"></a>1.顺序堆栈的存储结构</h2><p> 定义结构体如下：</p><pre><code>typedef struct{    DataType stack[MaxStackSize];    int top;} SeqStack;</code></pre><h2 id="2-顺序堆栈的操作实现"><a href="#2-顺序堆栈的操作实现" class="headerlink" title="2.顺序堆栈的操作实现"></a>2.顺序堆栈的操作实现</h2><p> 1.初始化</p><pre><code>void StackInitiate(SeqStack *S){    S-&gt;top = 0;            //初始化栈顶下标值（相当于数据元素个数）}</code></pre><p> 2.判断非空否</p><pre><code>int StackNotEmpty(SeqStack S)//非空返回1，空返回0。{    if(S.top &lt;= 0)return 0;    else return 1;}</code></pre><p> 3.入栈</p><pre><code>int StackPush(SeqStack *S, DataType x)//把数据元素值x存入顺序堆栈S中，成功返回1，失败返回0。{    if(S-&gt;top &gt;= MaxStackSize)    {        printf(&quot;堆栈已满，无法入栈！&quot;);        return 0;    }    else    {        S-&gt;stack[S-&gt;top] = x;        S-&gt;top ++;        return 1;    }}</code></pre><p> 4.出栈</p><pre><code>int StackPop(SeqStack *S, DataType *d)//取出的栈顶数据元素值由参数d带回，成功返回1，失败返回0。{    if(S-&gt;top &lt;= 0)    {        printf(&quot;堆栈已空！&quot;);        return 0;    }    else    {        S-&gt;top --;        *d = S-&gt;stack[S-&gt;top];        return 1;    }}</code></pre><p> 5.取栈顶数据元素</p><pre><code>int StackTop(SeqStack S, DataType *d){    if(S.top &lt;= 0)    {        printf(&quot;堆栈已空！&quot;);        return 0;    }    else    {        *d = S.stack[S.top -1];        return 1;    }}</code></pre><h1 id="堆栈的链式表示和实现（链式堆栈）"><a href="#堆栈的链式表示和实现（链式堆栈）" class="headerlink" title="堆栈的链式表示和实现（链式堆栈）"></a>堆栈的链式表示和实现（链式堆栈）</h1><h2 id="1-链式堆栈的存储结构"><a href="#1-链式堆栈的存储结构" class="headerlink" title="1.链式堆栈的存储结构"></a>1.链式堆栈的存储结构</h2><p> 结点结构体定义如下：</p><pre><code>typedef struct snode{    DataType data;    struct snode *next;} LSNode;</code></pre><h2 id="2-链式堆栈的操作实现"><a href="#2-链式堆栈的操作实现" class="headerlink" title="2.链式堆栈的操作实现"></a>2.链式堆栈的操作实现</h2><p> 1.初始化</p><pre><code>void StackInitiate(LSNode **head)//初始化带头结点链式堆栈{    *head = (LSNode *)malloc(sizeof(LSNode));    (*head)-&gt;next = NULL;}</code></pre><p> 2.判断非空否</p><pre><code>int StackNotEmpty(LSNode *head){    if(head-&gt;next == NULL)return 0;    else return 1;}</code></pre><p> 3.入栈</p><pre><code>void StackPush(LSNode *head, DataType x){    LSNode *p;    p = (LSNode *)malloc(sizeof(LSNode));    p-&gt;data = x;    p-&gt;next = head-&gt;next;    head-&gt;next = p;}</code></pre><p> 4.出栈</p><pre><code>int StackPop(LSNode *head, DataType *d){    LSNode *p = head-&gt;next;    if(p == NULL)    {        printf(&quot;堆栈已空！&quot;);        return 0;    }    head-&gt;next = p-&gt;next;    *d = p-&gt;data;    free(p);    return 1;}</code></pre><p> 5.取栈顶数据元素</p><pre><code>int StackTop(LSNode *head, DataType *d){    LSNode *p = head-&gt;next;    if(p == NULL)    {        printf(&quot;堆栈已空!&quot;);        return 0;    }    *d = p-&gt;data;    return 1;}</code></pre><p> 6.撤销动态申请空间</p><pre><code>void Destory(LSNode *head){    LSNode *p, *p1;    p = head;    while(p!=NULL)    {        p1 = p;        p = p-&gt;next;        free(p1);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;堆栈的基本概念&quot;&gt;&lt;a href=&quot;#堆栈的基本概念&quot; class=&quot;headerlink&quot; title=&quot;堆栈的基本概念&quot;&gt;&lt;/a&gt;堆栈的基本概念&lt;/h1&gt;&lt;p&gt; 堆栈是一种特殊的线性表，其数据元素以及数据元素间的逻辑关系和线性表的完全相同，其差别是：线性表允许在任意位置插入和删除数据元素，而堆栈只允许在固定一端进行插入和删除数据元素操作。&lt;br&gt; 堆栈中允许进行插入和删除操作的一端成为栈顶，另一端成为栈底；最后进入堆栈的数据元素总是最先退出堆栈，因此堆栈也称作后进先出的线性表。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆栈" scheme="https://lxzzzzzxl.github.io/tags/%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(C语言) —— 线性表(链表)</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(C%E8%AF%AD%E8%A8%80)%20%E2%80%94%E2%80%94%20%E7%BA%BF%E6%80%A7%E8%A1%A8(%E9%93%BE%E8%A1%A8)/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/30/数据结构(C语言) —— 线性表(链表)/</id>
    <published>2019-03-30T09:06:19.000Z</published>
    <updated>2019-04-10T08:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 上一篇博客我们详细的讲述了顺序表的实现，但以讲述的形式来记录数据结构这部分的笔记效率实在是有些低，所以接下来的部分我就单纯地列出知识点就完事了。嘻嘻嘻！~</p><a id="more"></a>  <h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p> 单链表结点的结构体：</p><pre><code>typedef struct Node{    DataType data;    struct Node *next;} SLNode;其中，data域用来存放数据元素，next域用来存放指向下一结点的指针。</code></pre><p> 单链表还分为带头结点结构和不带头结点结构两种。我们把指向单链表的指针称作头指针，头指针所指的不存放数据元素的第一个结点称作头结点。我们一般构造带头结点的单链表（以下讲解的也是带头结点的单链表）。</p><h2 id="单链表的操作实现"><a href="#单链表的操作实现" class="headerlink" title="单链表的操作实现"></a>单链表的操作实现</h2><h3 id="1-C语言的动态申请内存空间函数"><a href="#1-C语言的动态申请内存空间函数" class="headerlink" title="1.C语言的动态申请内存空间函数"></a>1.C语言的动态申请内存空间函数</h3><p> 要知道，单链表中的每一个结点，是在需要时才向系统申请的，这称作动态内存空间申请。动态申请的内存空间，当不再需要时，必须手动释放。C语言提供了动态申请内存空间的函数malloc()和动态释放函数内存空间的函数free()。这些函数包含在头文件malloc.h中。</p><pre><code>void *malloc(unsigned size);-&gt; 向系统动态申请size个字节的内存单元空间，函数返回值为所申请内存空间的首地址。void free(void *p);-&gt; p为内存空间首地址指针。sizeof(&lt;以定义的数据类型&gt;)-&gt; 计算所需内存空间的大小。</code></pre><h3 id="2-单链表的操作实现"><a href="#2-单链表的操作实现" class="headerlink" title="2.单链表的操作实现"></a>2.单链表的操作实现</h3><p> 1.初始化ListInitiate(SLNode **head)  </p><pre><code>void ListInitiate(SLNode **head)        //初始化{    *head = (SLNode *)malloc(sizeof(SLNode));    //申请头结点，由head指示其地址    (*head)-&gt;next = NULL;                //置结束标记NULL}</code></pre><p> 2.求当前数据元素个数ListLength(SLNode *head)</p><pre><code>int ListInitiate(SLNode *head){    SLNode *p = head;            //p指向头结点    int size = 0;                //size初始化为0    while(p-&gt;next!=NULL)        //循环计数    {        p = p-&gt;next;        size ++;    }    return size;}</code></pre><p> 3.插入ListInsert(SLNode *head, int i, DataType x)</p><pre><code>int ListInsert(SLNode *head, int i, DataType x)//在带头结点的单链表head的第i（0&lt;=i&lt;=size）个结点前//插入一个存放数据元素x的结点。插入成功返回1，失败返回0。{    SLNode *p, *q;    int j;    p = head;    j = -1;    while(p-&gt;next!=NULL &amp;&amp; j&lt;i-1)    //最终让p指向第i-1个结点    {        p = p-&gt;next;        j++;    }    if(j!=i-1)    {        printf(&quot;插入位置参数错误！\n&quot;);        return 0;    }    q = (SLNode *)malloc(sizeof(SLNode));    //生成新的结点    q-&gt;data = x;                            //新节点数据域赋值    q-&gt;next = p-&gt;next;                        //插入    p-&gt;next = q;    return 1;}</code></pre><p> 4.删除ListDelete(SLNode <em>head, int t, DataType </em>x)</p><pre><code>int ListDelete(SLNode *head, int i, DataType *x)//删除带头结点单链表head的第i（0&lt;=i&lt;=size-1）个结点//被删除结点的数据域值由x带回。删除成功返回1，失败返回0。{    SLNode *p, *s;    int j;    p = head;    j = -1;    while(p-&gt;next!=NULL &amp;&amp; p-&gt;next-&gt;next!=NULL &amp;&amp; j&lt;i-1)    //最终p指向第i-1个结点    {        p = p-&gt;next;        j++;    }    if(j!=i-1)    {        printf(&quot;删除位置参数错误！\n&quot;);        return 0;    }    s = p-&gt;next;                //指针s指向第i个结点    *x = s-&gt;data;                //赋值    p-&gt;next = p-&gt;next-&gt;next;    //删除    free(s);                    //释放内存空间    return 1;}</code></pre><p> 5.取数据元素ListGet(SLNode <em>head, int i, DataType </em>x)</p><pre><code>int ListGet(SLNode *head, int i, DataType *x){    SLNode *p;    int j;    p = head;    j = -1;    while(p-&gt;next!=NULL &amp;&amp; j&lt;i)    {        p = p-&gt;next;        j++;    }    if(j!=i)    {        printf(&quot;取元素位置参数错误！\n&quot;);        return 0;    }    *x = p-&gt;data;    return 1;}</code></pre><h1 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h1><p> 链表的最后一个结点的指针域不再是结束标记，而是指向整个链表的第一个结点，从而使链表形成一个环。（与单链表的实现差别不大，不做讨论。）</p><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p> 双向链表也有循环和非循环两种结构，这里讨论带头节点的双向循环链表。<br> 双向循环链表结点的结构体定义如下：</p><pre><code>typedef struct Node{    DataType data;         //数据域    struct Node *next;     //指向后驱结点的指针    struct Node *prior;    //指向前驱结点的指针} DLNode;</code></pre><h2 id="双向循环链表的操作实现"><a href="#双向循环链表的操作实现" class="headerlink" title="双向循环链表的操作实现"></a>双向循环链表的操作实现</h2><p> 1.初始化</p><pre><code>void ListInitiate(DLNode **head){    *head = (DLNode *)malloc(sizeof(DLNode));    (*head)-&gt;prior = *head;    (*head)-&gt;next = *head;}</code></pre><p> 2.插入数据元素</p><pre><code>int ListTnsert(DLNode *head, int i, DataType x)//在带头结点的双向循环链表head的第i（0&lt;=i&lt;=size）个结点前//插入一个存放数据元素x的结点。成功返回1，失败返回0。{    DLNode *p, *s;    int j;    p = head-&gt;next;    j = 0;    while(p-&gt;next!=head &amp;&amp; j&lt;i)            //寻找第i个结点    {        p = p-&gt;next;        j++;     }    if(j!=i)    {        printf(&quot;插入位置参数出错！&quot;);        return 0;    }    s = (DLNode *)malloc(sizeof(DLNode));    s-&gt;data = x;    s-&gt;prior = p-&gt;prior;            //插入步骤    p-&gt;prior-&gt;next = s;    s-&gt;next = p;    p-&gt;prior = s;    return 1;}</code></pre><p> 3.删除数据元素</p><pre><code>int ListDelete()//删除带头结点双向循环链表head的第i（0&lt;=i&lt;=size-1）个结点//被删除的结点的数据元素域值由x带回。成功返回1，失败返回0。{    DLNode *p;    int j;    p = head-&gt;next;    j = 0;    while(p-&gt;next!=head &amp;&amp; j&lt;i)    {        p = p-&gt;next;        j++;    }    if(j!=i)    {        printf(&quot;删除位置参数错误！&quot;);        return 0;    }    p-&gt;prior-&gt;next = p-&gt;next;    p-&gt;next-&gt;prior = p-&gt;prior;    free(p);    return 1;}</code></pre><p> 4.求当前数据元素个数</p><pre><code>int ListLength(DLNode *head){    DLNode *p = head;    int size = 0;    while(p-&gt;next != head)    {        p = p-&gt;next;        size ++;    }    return size;}</code></pre><p> 5.撤销内存空间</p><pre><code>void Destory(DLNode **head){    DLNode *p, *p1;    int i, n = ListLength(*head)    p = *head;    for(i = 0, i&lt;=n, i++)    {        p1 = p;        p = p-&gt;next;        free(p1);    }    *head = NULL;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 上一篇博客我们详细的讲述了顺序表的实现，但以讲述的形式来记录数据结构这部分的笔记效率实在是有些低，所以接下来的部分我就单纯地列出知识点就完事了。嘻嘻嘻！~&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://lxzzzzzxl.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(C语言) —— 线性表(顺序表)</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(C%E8%AF%AD%E8%A8%80)%20%E2%80%94%E2%80%94%20%E7%BA%BF%E6%80%A7%E8%A1%A8(%E9%A1%BA%E5%BA%8F%E8%A1%A8)/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/29/数据结构(C语言) —— 线性表(顺序表)/</id>
    <published>2019-03-29T09:06:19.000Z</published>
    <updated>2019-03-29T15:52:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p> 线性表是一种最简单的数据结构，其主要操作特点是可以在任意位置插入和删除一个数据元素。线性表有两种存储结构分别是顺序存储结构和链式存储结构，前者称为顺序表，后者称为链表，链表主要还分为单链表，循环单链表，双向循环链表三种。本篇我们先讲讲顺序表的实现。  </p><a id="more"></a>  <h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p> 这里涉及到了抽象数据类型的定义（什么是抽象数据类型），简单介绍一下：抽象数据类型是指一个逻辑概念上的类型和这个类型上的操作集合，而类型是一组值的集合。因此线性表的抽象数据类型主要包括两个方面：数据集合和在该数据集合上的操作集合。</p><h3 id="1-数据集合"><a href="#1-数据集合" class="headerlink" title="1.数据集合"></a>1.数据集合</h3><p> 线性表的数据集合可以表示为a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>,…,a<sub>n-1</sub>,每个数据元素的数据类型都是抽象数据元素的数据类型DataType。</p><pre><code>typedef int DataType;</code></pre><h3 id="2-操作集合"><a href="#2-操作集合" class="headerlink" title="2.操作集合"></a>2.操作集合</h3><p> (1) 初始化ListInitiate(L): 初始化线性表L。<br> (2) 求当前数据元素个数ListLength(L): 函数返回线性表L的当前数据元素个数。<br> (3) 插入数据元素ListInsert(L, i, x): 在线性表L的第i个数据元素前插入数据元素x。<br> (4) 删除数据元素ListDelete(L, i, x): 删除线性表L的第i个数据元素。<br> (5) 取数据元素ListGet(L, i, x): 取线性表L的第i个数据元素，由输出参数x带回。</p><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><p> 接下来我们讲解线性表的第一种存储结构—&gt;顺序存储结构（顺序表）</p><h3 id="顺序表的存储结构"><a href="#顺序表的存储结构" class="headerlink" title="顺序表的存储结构"></a>顺序表的存储结构</h3><p> 我们用结构体表示顺序表的结构，定义结构体SeqList如下：</p><pre><code>typedef struct{    DataType list[MaxSize];    int size;} SeqList;DataType为数组元素（数据元素）的数据类型，MaxSize表示数组的最大元素个数，size表示当前存储元素个数，且有size&lt;=MaxSize,SeqList为结构体名。</code></pre><h3 id="顺序表操作的实现"><a href="#顺序表操作的实现" class="headerlink" title="顺序表操作的实现"></a>顺序表操作的实现</h3><p> (1) 初始化ListInitiate(L)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInitiate</span><span class="params">(SeqList *L)</span><span class="comment">//初始化顺序表L</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L-&gt;size = <span class="number">0</span>;<span class="comment">//定义初始数据元素个数</span></span><br><span class="line">&#125;</span><br><span class="line">【说明】由于函数中要改变参数L的size域的值，所以参数L要设计为输出型参数，即设计为SeqList的指针类型。否则，size域的修改值将不会带回。</span><br></pre></td></tr></table></figure></p><p> (2) 求当前数据元素个数ListLength(L)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.size;返回顺序表L的当前数据元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> (3) 插入数据元素ListInsert(L, i, x)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SeqList *L, <span class="keyword">int</span> i, DataType x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在顺序表L的第i（0&lt;=i&lt;=size）个位置前插入数据元素值x</span></span></span><br><span class="line"><span class="function"><span class="comment">//插入成功返回1，失败返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;size &gt;= MaxSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"顺序表已满无法插入！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;L-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"参数i不合法！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从后向前依次后移数据，为插入做准备</span></span><br><span class="line"><span class="keyword">for</span>(j=L-&gt;size; j&gt;i; j--) L-&gt;size[j] = L-&gt;size[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">L-&gt;<span class="built_in">list</span>[i] = x;<span class="comment">//插入x</span></span><br><span class="line">L-&gt;size ++;    <span class="comment">//元素个数加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> (4) 删除数据元素ListDelete(L, i, x)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SeqList *L, <span class="keyword">int</span> i, DataType *x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除顺序表L中位置i（0&lt;=i&lt;=size-1）上的数据元素并保存到x中</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除成功返回1，失败返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;size &lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"顺序表已空，无数据可删！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">0</span> ||i&gt;L-&gt;size<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"参数i不合法！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*x = L-&gt;<span class="built_in">list</span>[i];<span class="comment">//保存删除的元素到x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从后向前依次前移</span></span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;=L-&gt;size; j++) L-&gt;size[j<span class="number">-1</span>] = L-&gt;size[j];</span><br><span class="line"></span><br><span class="line">L-&gt;size--;<span class="comment">//数据元素个数减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> (5) 取数据元素ListGet(L, i, x)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListGet</span><span class="params">(SeqList L, <span class="keyword">int</span> i, DataType *x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//取顺序表L中第i个数据元素存于x中，成功返回1，失败返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span> ||i&gt;L.size<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"参数i不合法！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*x = L.<span class="built_in">list</span>[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="顺序表应用举例"><a href="#顺序表应用举例" class="headerlink" title="顺序表应用举例"></a>顺序表应用举例</h2><p> 编程实现如下任务：</p><pre><code>建立一个线性表，首先依次输入数据元素1，2，3，...，10，然后删除数据元素5，最后依次显示当前线性表中的数据元素。假设该线性表的数据元素个数在最坏情况下不会超过100个。要求使用顺序表。</code></pre><p> 程序设计如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SeqList mylist;</span><br><span class="line"><span class="keyword">int</span> i, x;</span><br><span class="line"></span><br><span class="line">ListInitiate(&amp;mylist);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">ListInsert(&amp;mylist, i, i+<span class="number">1</span>);</span><br><span class="line">ListDelete(&amp;mylist, <span class="number">4</span>, &amp;x);</span><br><span class="line"><span class="comment">//显示顺序表当前数据元素</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ListLength(mylist); i++)</span><br><span class="line">&#123;</span><br><span class="line">ListGet(mylist, i, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 程序运行结果：</p><pre><code>1 2 3 4 6 7 8 9 10</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h1&gt;&lt;p&gt; 线性表是一种最简单的数据结构，其主要操作特点是可以在任意位置插入和删除一个数据元素。线性表有两种存储结构分别是顺序存储结构和链式存储结构，前者称为顺序表，后者称为链表，链表主要还分为单链表，循环单链表，双向循环链表三种。本篇我们先讲讲顺序表的实现。  &lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="顺序表" scheme="https://lxzzzzzxl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP网络编程 —— 基于TCP的服务器端/客户端</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/23/TCP%20IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E2%80%94%E2%80%94%20%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%20%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/23/TCP IP网络编程 —— 基于TCP的服务器端 客户端/</id>
    <published>2019-03-23T09:41:19.000Z</published>
    <updated>2019-03-23T13:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 前面我们已经学习了创建套接字的函数socket()和向套接字分配地址的函数bind(),接下来我们将正式讨论如何通过套接字收发数据；同时我们之前也介绍了面向连接和面向消息的2种数据传输方式，这篇博客也将具体讨论面向连接的服务器端/客户端的编写。 </p><a id="more"></a>  <h1 id="理解TCP和UDP"><a href="#理解TCP和UDP" class="headerlink" title="理解TCP和UDP"></a>理解TCP和UDP</h1><p> 根据数据传输方式的不同，基于网络协议的套接字一般分为TCP套接字和UDP套接字两种（本篇主要讲解TCP）；因为TCP套接字是面向连接的，因此又称基于流(stream)的套接字。<br> 这里推荐大家自行了解一下TCP/IP协议栈。</p><h1 id="实现基于TCP的服务器端-客户端"><a href="#实现基于TCP的服务器端-客户端" class="headerlink" title="实现基于TCP的服务器端/客户端"></a>实现基于TCP的服务器端/客户端</h1><h2 id="TCP服务器端的默认函数调用顺序"><a href="#TCP服务器端的默认函数调用顺序" class="headerlink" title="TCP服务器端的默认函数调用顺序"></a>TCP服务器端的默认函数调用顺序</h2><p> 绝大部分的TCP服务器端都按照以下的顺序调用函数：</p><pre><code>1. socket()          -&gt;创建套接字2. bind()            -&gt;分配套接字地址3. listen()          -&gt;等待连接请求状态4. accept()          -&gt;允许连接5. read()/write()    -&gt;数据交换6. close()           -&gt;断开连接</code></pre><p> 调用socket函数创建套接字，声明并初始化地址信息结构体变量，调用bind函数向套接字分配地址。这两个阶段之前已经讨论过了，下面讲解之后的几个过程。</p><h3 id="进入等待连接请求状态"><a href="#进入等待连接请求状态" class="headerlink" title="进入等待连接请求状态"></a>进入等待连接请求状态</h3><p> 只有调用了listen函数，客户端才能进入可发出连接请求状态。也就是说，这时客户端才能调用connect函数（提前调用将发生错误）。</p><pre><code>#include &lt;sys/socket.h&gt;int listen(int sock, int backlog);    -&gt;成功时返回0，失败时返回-1。    * sock        进入等待连接请求状态的套接字（服务器端套接字）文件描述符。    * backlog     连接请求等待队列的长度，若为5，则表示最多使5个连接请求进入队列。</code></pre><h3 id="受理客户端连接请求"><a href="#受理客户端连接请求" class="headerlink" title="受理客户端连接请求"></a>受理客户端连接请求</h3><p> 如果调用accept函数，函数将会自动创建一个新的套接字，用来连接到发起请求的客户端。</p><pre><code>#include &lt;sys/socket.h&gt;int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);    -&gt;成功时返回创建的套接字文件描述符，失败时返回-1。    * sock        服务器套接字的文件描述符。    * addr        客户端地址信息的变量地址值。    * addrlen     第二个参数addr结构体的长度，即存有客户端地址长度的的变量地址。</code></pre><h2 id="TCP客户端的默认函数调用顺序"><a href="#TCP客户端的默认函数调用顺序" class="headerlink" title="TCP客户端的默认函数调用顺序"></a>TCP客户端的默认函数调用顺序</h2><pre><code>1. socket()          -&gt;创建套接字2. connect()         -&gt;请求连接3. read()/write()    -&gt;交换数据4. close()           -&gt;断开连接</code></pre><h3 id="请求连接"><a href="#请求连接" class="headerlink" title="请求连接"></a>请求连接</h3><pre><code>#include &lt;sys/socket.h&gt;int connect(int sock, struct sockaddr *servaddr, socklen_t *addrlen);    -&gt;成功时返回0，失败时返回-1。    * sock        客户端套接字文件描述符    * servaddr    保存服务器端地址信息的变量地址值    * addrlen    第二个结构体参数servaddr的地址变量长度</code></pre><p> 客户端调用connect函数后，发生以下情况之一才会返回（完成函数调用）。</p><pre><code>1. 服务器端接收连接请求。2. 发生断网等异常情况而中断连接请求。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> TCP服务器端和客户端两者之间是交互的，并非互相独立，下面我们梳理一下整体流程：</p><pre><code>服务器端创建套接字后连续调用bind，listen函数进入等待状态，客户端创建套接字后调用connect函数发起连接请求。（注意：客户端只有等到服务器端调用listen函数后才能调用connect函数）同时要清楚，客户端调用connect函数之前，服务器端有可能率先调用了accept函数。此时，服务器端在调用accept函数时进入阻塞状态，直到客户端调用connect函数为止。</code></pre><p> 自此，TCP服务器端及客户端的实现和相关函数的说明就已经介绍完了，具体示例可以回看前面几篇博客给出的demo，若还有不明白的地方，请多加复习。<br> 本篇完结，白白~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 前面我们已经学习了创建套接字的函数socket()和向套接字分配地址的函数bind(),接下来我们将正式讨论如何通过套接字收发数据；同时我们之前也介绍了面向连接和面向消息的2种数据传输方式，这篇博客也将具体讨论面向连接的服务器端/客户端的编写。 &lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://lxzzzzzxl.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="套接字" scheme="https://lxzzzzzxl.github.io/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
      <category term="TCP" scheme="https://lxzzzzzxl.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP网络编程 —— 向套接字分配网络地址</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/21/TCP%20IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E2%80%94%E2%80%94%20%E5%90%91%E5%A5%97%E6%8E%A5%E5%AD%97%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/21/TCP IP网络编程 —— 向套接字分配网络地址/</id>
    <published>2019-03-21T13:20:19.000Z</published>
    <updated>2019-03-23T11:51:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 回顾一下服务器端套接字的实现流程，第一步是调用socket函数创建套接字，这个函数我们在上一篇博客已经详细讲解了；第二步则是调用bind函数分配IP地址及端口号，本篇博客就来讲讲bind函数的具体实现。</p><a id="more"></a>  <h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><pre><code>#include &lt;sys/socket.h&gt;int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);    -&gt; 成功时返回0，失败时返回-1。    * sockfd        要分配地址信息（IP地址和端口号）的套接字文件描述符。    * myaddr        存有地址信息的结构体变量地址值。    * addrlen       第二个结构体变量的长度。</code></pre><p> 如果此函数调用成功，则将第二个参数指定的地址信息分配给第一个参数中的相应套接字。下面先看一个服务器端常见的套接字初始化过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> serv_sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> *serv_port = <span class="string">"9190"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建服务器端套接字 */</span></span><br><span class="line">serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 地址信息初始化 */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">serv_addr.sin_port = htons(atoi(serv_port));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配地址信息 */</span></span><br><span class="line">bind(serv_sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br></pre></td></tr></table></figure></p><p> 相信看完这段代码的你，对socket和bind函数的调用并不会有太大的疑问，但你可能对地址信息初始化部分以及bind函数参数是怎么来的会产生很大的困惑，没有关系，我们依旧慢慢道来。</p><h2 id="地址信息的表示"><a href="#地址信息的表示" class="headerlink" title="地址信息的表示"></a>地址信息的表示</h2><p> 一般的，我们把要使用的IP地址和端口号以结构体的形式给出定义，这里用IPv4进行讲解，围绕该结构体讨论目标地址的表示方法：</p><pre><code>表示IPv4地址的结构体：struct sockaddr_in{    sa_family        sin_family;        //地址族（Address Family）    uint6_t          sin_port;          //16位TCP/UDP端口号    struct in_addr   sin_addr;          //32位IP地址    char             sin_zero[8];       //不使用}；</code></pre><p> 该结构体中提到的另一个结构体in_addr定义如下，它用来存放32位IP地址：</p><pre><code>struct in_addr{    In_addr_t        s_addr;            //32位IPv4地址}；</code></pre><p> 下面介绍以上两个结构体的成员变量~</p><h3 id="结构体sockaddr-in的成员分析"><a href="#结构体sockaddr-in的成员分析" class="headerlink" title="结构体sockaddr_in的成员分析"></a>结构体sockaddr_in的成员分析</h3><h4 id="成员sin-family"><a href="#成员sin-family" class="headerlink" title="成员sin_family"></a>成员sin_family</h4><p> 每种协议族适用的地址族均不同。比如，IPv4使用4字节地址族，IPv6使用16字节地址族。</p><pre><code>--------------------------------------------------------------地址族（Address Family）    |              含  义--------------------------------------------------------------    AF_INET                |         IPv4网络协议中使用的地址族    AF_INET6               |         IPv6网络协议中使用的地址族    AF_LOCAL               |     本地通信中采用的UNIX协议的地址族    --------------------------------------------------------------  </code></pre><h4 id="成员sin-port"><a href="#成员sin-port" class="headerlink" title="成员sin_port"></a>成员sin_port</h4><p> 该成员保存16位端口号（以网络字节序保存）。</p><h4 id="成员sin-addr"><a href="#成员sin-addr" class="headerlink" title="成员sin_addr"></a>成员sin_addr</h4><p> 该成员保存32位IP地址信息（也是以网络字节序保存）。</p><h4 id="成员sin-zero"><a href="#成员sin-zero" class="headerlink" title="成员sin_zero"></a>成员sin_zero</h4><p> 该成员无特殊含义，我们只要知道将其填充为0即可。</p><h2 id="网络字节序与地址变换"><a href="#网络字节序与地址变换" class="headerlink" title="网络字节序与地址变换"></a>网络字节序与地址变换</h2><p> 上面我们讲到，结构体sockaddr_in的成员sin_port和sin_addr的数据是以网络字节序保存的，至于什么是网络字节序这里我不进行赘述，大家自行了解，我们只讲字节序的转换；下面介绍两个字节序转换的函数：htons()和htonl()</p><ul><li>htons/htonl中的h代表主机(host)字节序；</li><li>htons/htonl中的n代表网络(network)字节序；</li><li>s指的是short，l指的是long（Linux中long类型占用4字节）；</li><li>htons用于端口号转换，htonl用于IP地址转换；</li></ul><h2 id="网络地址的初始化与分配"><a href="#网络地址的初始化与分配" class="headerlink" title="网络地址的初始化与分配"></a>网络地址的初始化与分配</h2><h3 id="将字符串信息转换为网络字节序的整型数"><a href="#将字符串信息转换为网络字节序的整型数" class="headerlink" title="将字符串信息转换为网络字节序的整型数"></a>将字符串信息转换为网络字节序的整型数</h3><p> 由于sockaddr_in结构体中保存的地址信息的成员为32位整型数，而我们熟悉的IP地址的表示是点分十进制的表示法。因此，在分配IP的时候，需将其表示为32位整型数，下面同样介绍两个函数，它们可以帮助我们将字符串形式的IP地址转换成32位整型数据，且它们在转换类型的同时能够进行网络字节序的转换：</p><pre><code>#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *string);    -&gt;成功时返回32位大端序整数型值，失败时返回INADDR_NONE。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">调用inet_addr函数的demo：</span><br><span class="line"><span class="comment">/* inet_addr.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *addr1=<span class="string">"1.2.3.4"</span>;</span><br><span class="line"><span class="keyword">char</span> *addr2=<span class="string">"1.2.3.256"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> conv_addr=inet_addr(addr1);</span><br><span class="line"><span class="keyword">if</span>(conv_addr==INADDR_NONE)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error occured! \n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#lx \n"</span>, conv_addr);</span><br><span class="line"></span><br><span class="line">conv_addr=inet_addr(addr2);</span><br><span class="line"><span class="keyword">if</span>(conv_addr==INADDR_NONE)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error occured! \n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#lx \n"</span>, conv_addr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>#include &lt;arpa/inet.h&gt;int inet_aton(const char *string, struct in_addr *addr);    -&gt;成功时返回1（true），失败时返回0（false）。    * string            含有需转换的IP地址信息的字符串地址值。    * addr              将保存转换结果的in_addr结构体变量的地址值。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">调用inet_aton函数的demo：</span><br><span class="line"><span class="comment">/* inet_aton.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *addr=<span class="string">"127.232.124.79"</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_inet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!inet_aton(addr,&amp;addr_inet.sin_addr))</span><br><span class="line">error_handling(<span class="string">"Conversion error"</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#x \n"</span>, addr_inet.sin_addr.s_addr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面这两个函数的区别在于，若要调用inet_addr函数，需要将转换后的IP地址信息代入sockaddr_in结构体中声明的in_addr结构体变量；而inet_aton函数则不需要此过程，因为传递in_addr结构体变量地址值时，函数会自动把结果传入该结构体变量，因此第二个函数的使用频率更高。</p><p> 再补充一个与inet_aton函数正好相反的函数，此函数可以把网络字节序的整数型IP地址转换为我们熟悉的字符串形式：</p><pre><code>#include &lt;arpa/inet.h&gt;char *inet_ntoa(struct in_addr adr);    -&gt;成功时返回转换的字符串地址值，失败时返回-1。</code></pre><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p> 我们再回顾一下一开始的地址信息初始化代码：</p><pre><code>/* 地址信息初始化1 */memset(&amp;serv_addr, 0, sizeof(serv_addr));serv_addr.sin_family = AF_INET;serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);serv_addr.sin_port = htons(atoi(serv_port));</code></pre><p> 再看另一种初始化方法：</p><pre><code>/* 地址信息初始化2 */memset(&amp;serv_addr, 0, sizeof(serv_addr));serv_addr.sin_family = AF_INET;serv_addr.sin_addr.s_addr = inet_addr(serv_ip);serv_addr.sin_port = htons(atoi(serv_port));</code></pre><p> 经过前面讲解的知识铺垫，我们一句一句来解释地址信息初始化的代码。</p><pre><code>1. memset(&amp;serv_addr, 0, sizeof(serv_addr));    //将每个字节初始化为0，在这里也就是将sin_zero初始化为02. serv_addr.sin_family = AF_INET;              //显而易见，通俗易懂3. serv_addr.sin_port = htons(atoi(serv_port)); //atoi函数把字符串类型的值转换成整数型最后看有差异的第三句，inet_addr(serv_ip)相信大家都好理解，我们主要看htonl(INADDR_ANY)，这是个什么格式？原来，使用inet_addr(serv_ip)，每次都要输入IP地址会有些繁琐，所以可以利用常数INADDR_ANY分配服务器端的IP地址，若采用这种方式，则可自动获取运行服务器端的计算机的IP地址，不必亲自输入。因此，服务器端中优先考虑第二种，而客户端一般不会采用。</code></pre><p> 好啦，讲完啦，白白~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 回顾一下服务器端套接字的实现流程，第一步是调用socket函数创建套接字，这个函数我们在上一篇博客已经详细讲解了；第二步则是调用bind函数分配IP地址及端口号，本篇博客就来讲讲bind函数的具体实现。&lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://lxzzzzzxl.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="套接字" scheme="https://lxzzzzzxl.github.io/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP网络编程 —— 套接字类型与协议设置</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/21/TCP%20IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E2%80%94%E2%80%94%20%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/21/TCP IP网络编程 —— 套接字类型与协议设置/</id>
    <published>2019-03-21T04:46:19.000Z</published>
    <updated>2019-03-21T13:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 上一篇博文讲解了Linux下的套接字的实现过程，其中涉及到了一些函数，我们只是直接调用了它们，并没有过多的解释，那么函数的具体用法在这篇博客以及接下来的几篇中将会进行详细的介绍，本篇介绍的是创建套接字的函数socket()。</p><a id="more"></a> <h1 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h1><pre><code>#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);    -&gt; 成功时返回文件描述符，失败时返回-1。    * domain      套接字中使用的协议族（Protocol Family）信息。    * type        套接字数据传输类型信息。    * protocol    计算机间通信中使用的协议信息。</code></pre><p> 相信看过前一篇的对这个函数并不陌生，但是对函数中的这几个参数可能就不是很明白了，没有关系，我们慢慢道来。</p><h2 id="协议族（Protocol-Famliy）"><a href="#协议族（Protocol-Famliy）" class="headerlink" title="协议族（Protocol Famliy）"></a>协议族（Protocol Famliy）</h2><p> 奶油意大利面和番茄意大利面都属于意大利面的一种，相似的，套接字通信中的协议也是有分类的。socket函数的第一个参数就是传递套接字中使用的协议分类信息。此协议分类信息我们便称之为协议族，可分成如下几类：</p><pre><code>-------------------------------------------------名 称                        协 议 族-------------------------------------------------PF_INET                     IPv4互联网协议族PF_INET6                    IPv6互联网协议族PF_LOCAL                    本地通信的UNIX协议族PF_PACKET                   底层套接字的协议族PF_IPX                      IPX Novell协议族</code></pre><p> 以上的协议族在头文件sys/socket.h中声明；另外我们将重点放在PF_INET对应的IPv4互联网协议族上，因为其他协议族并不常用或尚未普及。</p><h2 id="套接字类型（Type）"><a href="#套接字类型（Type）" class="headerlink" title="套接字类型（Type）"></a>套接字类型（Type）</h2><p> 套接字类型指的是套接字的数据传输方式，由socket函数的第二个参数传递；下面介绍2种具有代表性的数据传输方式：</p><h3 id="套接字类型1：面向连接的套接字（SOCK-STREAM）"><a href="#套接字类型1：面向连接的套接字（SOCK-STREAM）" class="headerlink" title="套接字类型1：面向连接的套接字（SOCK_STREAM）"></a>套接字类型1：面向连接的套接字（SOCK_STREAM）</h3><p> 如果向socket函数的第二个参数传递SOCK_STREAM，将创建面向连接的套接字，此传输方式的特征如下：</p><ul><li>传输过程中数据不会消失</li><li>按序传输数据</li><li>传输的数据不存在数据边界</li></ul><h3 id="套接字类型2：面向消息的套接字（SOCK-DGRAM）"><a href="#套接字类型2：面向消息的套接字（SOCK-DGRAM）" class="headerlink" title="套接字类型2：面向消息的套接字（SOCK_DGRAM）"></a>套接字类型2：面向消息的套接字（SOCK_DGRAM）</h3><p> 如果向socket函数的第二个参数传递SOCK_DGRAM,将创建面向消息的套接字，此传输方式的特征如下：</p><ul><li>强调快速传输而非传输顺序</li><li>传输的数据可能丢失也可能损毁</li><li>传输的数据有数据边界</li><li>限制每次传输的数据大小</li></ul><p>注：面向连接的套接字需要有相同类型的另一套接字与之连接，而面向消息的套接字不存在连接的概念。</p><h2 id="协议的最终选择"><a href="#协议的最终选择" class="headerlink" title="协议的最终选择"></a>协议的最终选择</h2><p> 下面讲解socket函数的第三个参数，该参数决定最终采用的协议；在大部分情况下，传递前两个参数即可创建所需的套接字，所以可以向第三个参数传递0；如果数据传输方式相同，但协议不同，则此时需要通过第三个参数指定具体的协议信息。下面用两个例子来理解第三个参数。<br> 创建满足如下要求的套接字：</p><pre><code>1.“IPv4协议族中面向连接的套接字”很明显，前两个参数就是PF_INET和SOCK_STREAM了，而满足前两个条件的协议就只有IPPROTO_TCP了，因此我们可以向第三个参数传递0或是如下格式：int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);  2.&quot;IPv4协议族中面向消息的套接字&quot;同样的，前两个参数就是PF_INET和SOCK_DGRAM,满足前两个条件的协议只有IPPROTO_UDP,所以该套接字如下：int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);</code></pre><p>自此，整个socket函数就算是讲解完了，大家可以回过头去看看前一篇博客给出的demo，相信你们对socket函数部分会比之前有更深的理解。<br>本篇完结，白白。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 上一篇博文讲解了Linux下的套接字的实现过程，其中涉及到了一些函数，我们只是直接调用了它们，并没有过多的解释，那么函数的具体用法在这篇博客以及接下来的几篇中将会进行详细的介绍，本篇介绍的是创建套接字的函数socket()。&lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://lxzzzzzxl.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="套接字" scheme="https://lxzzzzzxl.github.io/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP网络编程 —— 套接字(socket)</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/19/TCP%20IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E5%A5%97%E6%8E%A5%E5%AD%97(socket)/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/19/TCP IP网络编程—套接字(socket)/</id>
    <published>2019-03-18T16:01:19.000Z</published>
    <updated>2019-03-19T12:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 做嵌入式物联网的，不学点网络编程好像有点说不过去，暑假学的RT-Thread的网络编程仅仅是了解了怎么用，可以说是知其然却不知其所以然，所以还是老老实实从基础开始，学一遍网络编程吧，挑了网友推荐的《TCP/IP网络编程》，感觉还不错。看了第一章，学习了Linux和Windows下的socket编程相关函数，本篇博客就简单的对Linux下的socket创建过程做下笔记。</p><a id="more"></a>  <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p> 首先还是要介绍一下基础概念，所谓网络编程，简单来说就是编写程序使两台联网的计算机相互交换数据，而套接字呢，你可以理解为计算机连接网络的工具，进而引申为两台计算机之间的网络连接。<br> 套接字大致还可以分为两种，一种是服务器端(server)的套接字，一种是客户端(client)的套接字，下面我们就对这两种套接字的创建过程及使用方法作详细的介绍。  </p><h2 id="服务器端-server-套接字"><a href="#服务器端-server-套接字" class="headerlink" title="服务器端(server)套接字"></a>服务器端(server)套接字</h2><p> 两台计算机要进行通信/数据交换，那么作为服务器端的计算机要做什么事情呢？自然是等待(监听)接受连接请求了，这个过程可归纳为以下四步：</p><p> 第一步：调用socket函数创建套接字。  </p><pre><code>#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);-&gt; 成功时返回文件描述符，失败时返回-1。</code></pre><p> 第二步：调用bind函数分配IP地址和端口号。</p><pre><code>#include &lt;sys/socket.h&gt;int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);-&gt; 成功时返回0，失败时返回-1。</code></pre><p> 第三步：调用listen函数转为可接收请求状态。</p><pre><code>#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);-&gt; 成功时返回0，失败时返回-1。</code></pre><p> 第四步：调用accept函数受理连接请求。</p><pre><code>#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);-&gt; 成功时返回文件描述符，失败时返回-1。</code></pre><h2 id="客户端-client-套接字"><a href="#客户端-client-套接字" class="headerlink" title="客户端(client)套接字"></a>客户端(client)套接字</h2><p> 那么客户端套接字，也就是请求连接服务器的套接字，它的创建比服务器端套接字简单多了，只有以下两步：  </p><p> 第一步：调用socket函数创建套接字。</p><pre><code>#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);-&gt; 成功时返回文件描述符，失败时返回-1。</code></pre><p> 第二步：调用connect函数向服务器端发送连接请求。</p><pre><code>#include &lt;sys/socket.h&gt;int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addrlen);-&gt; 成功时返回0，失败时返回-1。</code></pre><h1 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h1><p> 通过调用上述介绍的函数，就可以编写自己的server/client程序进行模拟通讯啦，下面贴上两个Linux下的demo程序让大家理解整个过程的实现。</p><h2 id="“Hello-World！”服务器端demo"><a href="#“Hello-World！”服务器端demo" class="headerlink" title="“Hello World！”服务器端demo"></a>“Hello World！”服务器端demo</h2><p> 服务器端（server）是能够受理连接请求的程序。下面demo构建的服务器收到连接请求后向请求者返回“Hello World!”答复。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello_server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> serv_sock;</span><br><span class="line"><span class="keyword">int</span> clnt_sock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> message[]=<span class="string">"Hello World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serv_sock=socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//调用socket函数创建套接字。</span></span><br><span class="line"><span class="keyword">if</span>(serv_sock == <span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">serv_addr.sin_family=AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">serv_addr.sin_port=htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bind(serv_sock, (struct sockaddr*) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)<span class="comment">//调用bind函数分配IP地址和端口号。</span></span><br><span class="line">error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(listen(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>)<span class="comment">//调用listen函数将套接字转为可接收连接状态。</span></span><br><span class="line">error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">clnt_addr_size=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">clnt_sock=accept(serv_sock, (struct sockaddr*) &amp;clnt_addr, &amp;clnt_addr_size);<span class="comment">//调用accept函数受理连接请求。如果在没有连接请求的的情况下调用该函数，则不会返回，直到有连接请求为止。</span></span><br><span class="line"><span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line"></span><br><span class="line">write(clnt_sock, message, <span class="keyword">sizeof</span>(message));<span class="comment">//数据传输函数</span></span><br><span class="line">close(clnt_sock);</span><br><span class="line">close(serv_sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="客户端demo"><a href="#客户端demo" class="headerlink" title="客户端demo"></a>客户端demo</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello_client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> str_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sock=socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//创建套接字，但此时套接字并不马上分为服务器端和客户端。如果紧接着调用bind，listen函数，将成为服务器端套接字；如果调用connect函数，将成为客户端套接字。</span></span><br><span class="line"><span class="keyword">if</span>(sock == <span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">serv_addr.sin_family=AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">serv_addr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(connect(sock, (struct sockaddr*) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)<span class="comment">//调用connect函数向服务器端发送连接请求。</span></span><br><span class="line">error_handling(<span class="string">"connect() error"</span>);</span><br><span class="line"></span><br><span class="line">str_len=read(sock, message, <span class="keyword">sizeof</span>(message)<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(str_len==<span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">"read() error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Message from server : %s \n"</span>, message);</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_server.c -o hserver</span><br><span class="line">-&gt;编译 hello_server.c文件并生成可执行文件hserver。</span><br><span class="line">./hserver <span class="number">9190</span></span><br><span class="line">-&gt;运行当前目录下的hserver文件</span><br><span class="line">运行结果：等待客户端连接。</span><br><span class="line">gcc hello_client.c -o hclient</span><br><span class="line">-&gt;编译......</span><br><span class="line">./hclient <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">9190</span></span><br><span class="line">-&gt;运行......</span><br><span class="line">运行结果：Hello World!</span><br></pre></td></tr></table></figure><p>本篇完结，谢谢观看，白了个白。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 做嵌入式物联网的，不学点网络编程好像有点说不过去，暑假学的RT-Thread的网络编程仅仅是了解了怎么用，可以说是知其然却不知其所以然，所以还是老老实实从基础开始，学一遍网络编程吧，挑了网友推荐的《TCP/IP网络编程》，感觉还不错。看了第一章，学习了Linux和Windows下的socket编程相关函数，本篇博客就简单的对Linux下的socket创建过程做下笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://lxzzzzzxl.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="套接字" scheme="https://lxzzzzzxl.github.io/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>C语言排序算法复习</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/01/C%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/01/C语言排序算法复习/</id>
    <published>2019-03-01T05:41:19.000Z</published>
    <updated>2019-03-01T12:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前还在不紧不慢的状态中，转眼间找实习就开始了，第一个目标是CVTE的嵌入式软件开发实习生的岗位，昨天刚刚网申，听了宣讲会，明天就要参加在线测评了（还是广州站的最后一次机会……），时间很紧，抓紧时间复习一下一些知识点，看过一点往年试题，排序算法部分考得挺多，便整理了一下。  </p><a id="more"></a>  <h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p> <strong>基本思想：比较相邻的两个数，如果前者比后者大，则进行交换。每一轮排序结束，选出一个未排序中最大的数放到数组后面。若数组长度为n，则需进行n-1轮排序才能得出结果。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 冒泡排序算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr ,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)                         <span class="comment">//进行n-1轮排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)                   <span class="comment">//对未排序部分进行排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[j+<span class="number">1</span>];             <span class="comment">//比较交换</span></span><br><span class="line">arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">arr[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data[]=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);        <span class="comment">//计算数组长度</span></span><br><span class="line">bubbleSort(data,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组长度为：%d\n"</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"排序后的数组为：\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n;a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,data[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p> <strong>基本思想：和交换排序不同的是它不用进行交换操作，而是用一个临时变量存储当前值。当前面的元素比后面大时，先把后面的元素存入临时变量，前面元素的值放到后面元素位置，再到最后把其值插入到合适的数组位置。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">j=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;arr[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line"><span class="keyword">while</span>(temp&lt;arr[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">arr[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); </span><br><span class="line">InsertSort(arr,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组长度为：%d\n"</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"排序后的数组为:\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h1><p> <strong>基本思想：依次选出数组最小的数放到数组的前面。首先从数组的第二个元素开始往后遍历，找出最小的数放到第一个位置。再从剩下数组中找出最小的数放到第二个位置。以此类推，直到数组有序。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> key=i;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[key])</span><br><span class="line">&#123;</span><br><span class="line">key=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(key!=i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[key];arr[key]=arr[i];arr[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[]=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);        <span class="comment">//计算数组长度</span></span><br><span class="line">    SelectSort(data,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数组长度为：%d\n"</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序后的数组为：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n;a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,data[a]);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完结，继续复习，白了个白。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前还在不紧不慢的状态中，转眼间找实习就开始了，第一个目标是CVTE的嵌入式软件开发实习生的岗位，昨天刚刚网申，听了宣讲会，明天就要参加在线测评了（还是广州站的最后一次机会……），时间很紧，抓紧时间复习一下一些知识点，看过一点往年试题，排序算法部分考得挺多，便整理了一下。  &lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://lxzzzzzxl.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="排序算法" scheme="https://lxzzzzzxl.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AT指令下的W600-GET-简单的天气信息（心知天气）</title>
    <link href="https://lxzzzzzxl.github.io/2019/02/15/AT%E6%8C%87%E4%BB%A4%E4%B8%8B%E7%9A%84W600-GET-%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%A9%E6%B0%94%E4%BF%A1%E6%81%AF%EF%BC%88%E5%BF%83%E7%9F%A5%E5%A4%A9%E6%B0%94%EF%BC%89/"/>
    <id>https://lxzzzzzxl.github.io/2019/02/15/AT指令下的W600-GET-简单的天气信息（心知天气）/</id>
    <published>2019-02-15T14:25:19.000Z</published>
    <updated>2019-02-15T15:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自从春节以来，学习就不在状态，一直想做好久了的百度语音识别项目迟迟没有进展，断断续续看了好多文档和资料，就是不知从何下手，今天写的这篇博客没有太大的目的，就是想让自己找回状态，脉动回来，哈哈哈！就写一个W600调用心知天气API吧，AT指令下的，很简单。  </p><a id="more"></a><h1 id="心知天气使用"><a href="#心知天气使用" class="headerlink" title="心知天气使用"></a>心知天气使用</h1><p>简单说一下：<br>1.首先，老套路，去注册一个心知天气账号，（有免费会员和付费的给你选）获取你的API密钥，后面会用到。<br>2.紧接着，看一个示例：</p><p> <img src="https://i.imgur.com/Q3Fv1mb.png" alt> </p><p> 这是一个免费的天气API,双击如下示例URL或者复制粘贴到浏览器可以看到返回结果：<br> <a href="https://api.seniverse.com/v3/weather/now.json?key=6dxwrt9yzsyj3vmr&amp;location=beijing&amp;language=zh-Hans&amp;unit=c" target="_blank" rel="noopener">https://api.seniverse.com/v3/weather/now.json?key=6dxwrt9yzsyj3vmr&amp;location=beijing&amp;language=zh-Hans&amp;unit=c</a> </p><pre><code>{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;北京,北京,中国&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;+08:00&quot;},&quot;now&quot;:{&quot;text&quot;:&quot;晴&quot;,&quot;code&quot;:&quot;1&quot;,&quot;temperature&quot;:&quot;-3&quot;},&quot;last_update&quot;:&quot;2019-02-15T22:45:00+08:00&quot;}]}</code></pre><h1 id="W600-GET-API"><a href="#W600-GET-API" class="headerlink" title="W600 GET API"></a>W600 GET API</h1><p>当然啦，上面讲的是在PC端简单的调用API给大家看看现象，我们要做的是通过W600,GET到服务器上的信息，我们用AT指令来实现：<br>1.首先将W600设置为STA模式连接上路由器<br>2.接着连接心知天气服务器  </p><pre><code>AT+CIPSTART=&quot;TCP&quot;,&quot;api.seniverse.com&quot;,80</code></pre><p>3.设置为透传模式</p><pre><code>AT+CIPMODE=1</code></pre><p>4.开启透传</p><pre><code>AT+CIPSEND</code></pre><p>5.发送GET+URL</p><pre><code>GET https://api.seniverse.com/v3/weather/now.json?key=6dxwrt9yzsyj3vmr&amp;location=beijing&amp;language=zh-Hans&amp;unit=c</code></pre><p>现象如下：</p><p><img src="https://i.imgur.com/gZnN0nB.png" alt></p><p>此处返回的天气信息跟PC端的试验其实是一样的，只是在串口助手中文显示为乱码而已。</p><p>注：本篇博客只是初略的介绍了如何在AT指令下GET服务器信息，涉及更多心知天气的内容以及网络编程的知识，请大家自行了解。</p><p>本篇完结！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;自从春节以来，学习就不在状态，一直想做好久了的百度语音识别项目迟迟没有进展，断断续续看了好多文档和资料，就是不知从何下手，今天写的这篇博客没有太大的目的，就是想让自己找回状态，脉动回来，哈哈哈！就写一个W600调用心知天气API吧，AT指令下的，很简单。  &lt;/p&gt;
    
    </summary>
    
      <category term="WIFI" scheme="https://lxzzzzzxl.github.io/categories/WIFI/"/>
    
    
      <category term="W600" scheme="https://lxzzzzzxl.github.io/tags/W600/"/>
    
  </entry>
  
  <entry>
    <title>百度AI — 语音识别</title>
    <link href="https://lxzzzzzxl.github.io/2019/02/03/%E7%99%BE%E5%BA%A6AI%20%E2%80%94%20%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    <id>https://lxzzzzzxl.github.io/2019/02/03/百度AI — 语音识别/</id>
    <published>2019-02-03T13:12:19.000Z</published>
    <updated>2019-02-03T14:49:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 自寒假开始学习RT-Thread操作系统以来，已经完成了对基础内核部分以及QEMU网络编程的学习；从一开始对逐渐火起来的RT-Thread的好奇，到刚开始接触时的一脸懵逼，到现在的感叹RT-Thread的强大，真是深深体会到不断学习的重要性；今天的这篇博客是做QEMU网络编程结课作业时学习到的一点小内容，主要是对百度语音识别API的使用：</p><a id="more"></a><h1 id="百度语音识别"><a href="#百度语音识别" class="headerlink" title="百度语音识别"></a>百度语音识别</h1><p> 百度语音识别简单来说就是百度AI通过API的方式给开发者提供一个通用的HTTP接口，开发者通过这个接口上传音频文件，返回识别结果；通过学习使用百度语音识别API，我们就可以做一个语音控制单片机继而控制外设的设计，这也是我接下来要做的，做一个能交互的语音控制设计，想想就很酷！<br> 首先我们要注册一个百度开发者账号，然后创建一个语音识别的应用，这部分大家自行百度~  </p><h1 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h1><h2 id="1-获取-Access-Token："><a href="#1-获取-Access-Token：" class="headerlink" title="1.获取 Access Token："></a>1.获取 Access Token：</h2><p>（这里推荐一个软件：Postman，貌似要翻墙，大家自行了解）<br>向授权服务地址 <a href="https://aip.baidubce.com/oauth/2.0/token" target="_blank" rel="noopener">https://aip.baidubce.com/oauth/2.0/token</a> 发送请求（推荐使用POST），并在URL中带上以下参数：</p><ul><li>grant_type： 必须参数，固定为client_credentials；</li><li>client_id： 必须参数，应用的API Key；</li><li>client_secret： 必须参数，应用的Secret Key；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例： </span><br><span class="line">https://openapi.baidu.com/oauth/2.0/token? grant_type=client_credentials&amp;client_id=Va5yQRHl********LT0vuXV4&amp;client_secret= 0rDSjzQ20XUj5i********PQSzr5pVw2&amp;</span><br></pre></td></tr></table></figure><p>下图为使用Postman:<br><img src="https://i.imgur.com/WkhTJNl.jpg" alt></p><h2 id="使用Access-Token进行语音识别"><a href="#使用Access-Token进行语音识别" class="headerlink" title="使用Access Token进行语音识别"></a>使用Access Token进行语音识别</h2><p>采用Raw方式，详见下图：<br><img src="https://i.imgur.com/c5fcDkj.png" alt><br><img src="https://i.imgur.com/qiFBayp.png" alt></p><p>更多详细内容，大家参考百度AI文档中心的相关部分<a href="https://ai.baidu.com/docs#/ASR-API/77e2b22e" target="_blank" rel="noopener">https://ai.baidu.com/docs#/ASR-API/77e2b22e</a> ，相信各位看完文档再来看本篇博客会豁然开朗~<br>本片完结！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 自寒假开始学习RT-Thread操作系统以来，已经完成了对基础内核部分以及QEMU网络编程的学习；从一开始对逐渐火起来的RT-Thread的好奇，到刚开始接触时的一脸懵逼，到现在的感叹RT-Thread的强大，真是深深体会到不断学习的重要性；今天的这篇博客是做QEMU网络编程结课作业时学习到的一点小内容，主要是对百度语音识别API的使用：&lt;/p&gt;
    
    </summary>
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/categories/STM32/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
      <category term="百度AI" scheme="https://lxzzzzzxl.github.io/tags/%E7%99%BE%E5%BA%A6AI/"/>
    
  </entry>
  
  <entry>
    <title>正点原子—按键输入代码解析</title>
    <link href="https://lxzzzzzxl.github.io/2019/01/27/%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E2%80%94%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lxzzzzzxl.github.io/2019/01/27/正点原子—按键输入代码解析/</id>
    <published>2019-01-27T04:12:19.000Z</published>
    <updated>2019-01-28T10:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信很多人学习STM32看的教程资料什么的，不是正点原子就是野火，这两家的资料都是比较有名的，我用的就是正点原子的，这篇博客我来讲一下我当初学习按键输入例程时的疑惑，我到论坛上看了，大部分初学者跟我有同样的问题，究尽是什么问题呢？我们先上代码：  </p><a id="more"></a>  <h1 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">static</span> u8 key_up=<span class="number">1</span>;<span class="comment">//按键按松开标志</span></span><br><span class="line"><span class="keyword">if</span>(mode)key_up=<span class="number">1</span>;  <span class="comment">//支持连按  </span></span><br><span class="line"><span class="keyword">if</span>(key_up&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//去抖动 </span></span><br><span class="line">key_up=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(KEY1==<span class="number">0</span>)<span class="keyword">return</span> KEY_1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)<span class="keyword">return</span> KEY_2;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>)key_up=<span class="number">1</span>;     </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就出在这个KEY_Scan()函数上（上面贴的代码我修改过，原版是有4个按键的，我改成2个，但实质上是一样的，这样方便大家理解），前面GPIO初始化部分，相信看过跑马灯例程过来的都没什么问题，我们主要看看KEY_Scan()这个函数，这个函数是带参数mode的，且有返回值，当初我跟大部分网友的疑惑在于为啥mode为1就支持连续按，为0就不支持呢，原理是啥？代码读一遍下来感觉为0为1没差啊。<br>为什么会有这样的疑惑，归结起来还是C语言基础太差，还有一个很重要的原因就是，大家阅读代码就只是这样读一遍下来，然而这里你要读上两遍才能看出问题所在。下面我们一点一点来讲……<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> u8 key_up=<span class="number">1</span>;<span class="comment">//按键按松开标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这句话咋一看没什么了不起，不就是定义key_up的值为1吗？是这样没错，但是大家可能忽视了前面</span></span><br><span class="line"><span class="comment">有个static，或者知道有static却不知道它的含义，这就是为什么我说C语言基础差的原因，static用</span></span><br><span class="line"><span class="comment">在这里相当于定义了一个static局部变量，下面是重点：static局部变量只被初始化一次，下一次依据</span></span><br><span class="line"><span class="comment">上一次结果值。意思也就是说，这句话只跑一次！！！ */</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mode)</span><br><span class="line">key_up=<span class="number">1</span>;  <span class="comment">//是否支持连按 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里我把原代码这样写，可能大家见这样形式的比较熟悉，很明显是个if判断语句，如果是真，执行</span></span><br><span class="line"><span class="comment">key_up=1；如果不为真，跳过，执行下一行；那么真不真，相信大家应该都明白，1真0不真咯，如果不</span></span><br><span class="line"><span class="comment">懂，还是先去翻翻C语言吧。 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key_up&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//去抖动 </span></span><br><span class="line">key_up=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(KEY1==<span class="number">0</span>)<span class="keyword">return</span> KEY_1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)<span class="keyword">return</span> KEY_2;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>)key_up=<span class="number">1</span>;     </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无按键按下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 剩下的我们合在一起看，前面我们定义了按键松开标志key_up=1，如果满足key_up为真且KEY1或</span></span><br><span class="line"><span class="comment">KEY2有一个为0（被按下为0），那么我们就把按键标志key_up置0，同时判断是哪个键被按下，然后输</span></span><br><span class="line"><span class="comment">出返回值；如果KEY1,KEY2都没被按下，则key_up还是置1，返回0。 */</span></span><br></pre></td></tr></table></figure><p> 好了，以上基本代码已经讲解完了，可能有的人已经领悟了问题所在，有的人还迷迷糊糊，没关系，我们接下来直击重点：<br> 没有明白的人，我相信只剩逻辑问题了，我们代码中有这样一句话<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key_up&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p> 这句代码告诉我们，你想知道哪个键被按下不仅仅是判断是否有按键被按下这么简单，还要满足按键标志key_up为1才行；如果你不想支持连按，即mode=0，因为我们初始了key_up=1，当我们按下按键，确实能成功响应返回值，但同时key_up也被置0，如果你的手不放开，程序是永远无法进入下一次按键判断的，因为此时key_up为0，不满足条件；只有当你把手放开，程序执行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>)key_up=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p> 这时key_up才被重新置1，下一次按键才能被检测判断，这就是所谓的不支持连按。</p><p> 那么如果你是想支持连按的，因为mode=1，程序每次跑，判断到mode=1，为真，就自动将key_up置1了，尽管你的手不放开，程序都能进入按键检测，你一直按着哪个键，它就不停返回对应的返回值，这就是所谓的支持连按。  </p><p>完结！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;相信很多人学习STM32看的教程资料什么的，不是正点原子就是野火，这两家的资料都是比较有名的，我用的就是正点原子的，这篇博客我来讲一下我当初学习按键输入例程时的疑惑，我到论坛上看了，大部分初学者跟我有同样的问题，究尽是什么问题呢？我们先上代码：  &lt;/p&gt;
    
    </summary>
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/categories/STM32/"/>
    
      <category term="正点原子" scheme="https://lxzzzzzxl.github.io/categories/STM32/%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>STM32F103 UCGUI3.90移植+触摸屏教程</title>
    <link href="https://lxzzzzzxl.github.io/2019/01/24/STM32F103%20UCGUI3.90%E7%A7%BB%E6%A4%8D+%E8%A7%A6%E6%91%B8%E5%B1%8F%E6%95%99%E7%A8%8B/"/>
    <id>https://lxzzzzzxl.github.io/2019/01/24/STM32F103 UCGUI3.90移植+触摸屏教程/</id>
    <published>2019-01-24T11:12:19.000Z</published>
    <updated>2019-01-28T10:18:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 这是大二暑假学习STM32时写的一篇的教程，当初移植的时候耗费了好大的力气，集齐了万千网友的智慧和教程，归纳总结整理出来的，在此记录一下。</p><a id="more"></a>  <h1 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一.准备工作"></a>一.准备工作</h1><p>1.采用UCGUI3.90版本———下载UCGUI3.90.zip。  <a href="/download/UCGUI3.90.zip">点击下载</a></p><p>2.准备好自己的LCD驱动程序。</p><p>3.自行新建一个工程模板（本人采用的是正点原子战舰开发板的TFTLCD显示实验例程作为模板）备用。</p><p>4.解压打开UCGUI文件夹，1）将Start文件夹中的Config和GUI文件夹复制粘贴到自己的工程文件中。2）将Sample\GUI_X中的GUI_X.C复制粘贴到Config中。 </p><p><img src="https://i.imgur.com/OM6TO9c.png" alt><br><img src="https://i.imgur.com/jxWOjk4.png" alt>  </p><p>5.由于UCGUI\Core下有LCD.C和LCD.H文件，而例程中也有，为了防止重复，需将原工程中的LCD.C和LCD.H修改为其他名称，例：ILI93XX.C ILI93XX.H</p><p>6.修改ILI93XX.C中的LCD初始化函数LCD_Init，将其改为TFTLCD_Init（名称自定）</p><p>7.将ILI93XX.H中原LCD改为TFTLCD,全局修改。  </p><p><img src="https://i.imgur.com/P7AC9Gk.png" alt></p><h1 id="二．开始移植"><a href="#二．开始移植" class="headerlink" title="二．开始移植"></a>二．开始移植</h1><p>1.将文件添加进工程</p><p><img src="https://i.imgur.com/ZCeM8YD.png" alt><br>2.添加路径</p><p><img src="https://i.imgur.com/FhZ2wTk.png" alt><br>3.接下来需要修改三个文件GUIConf.h   LCDConf.h   LCDDummy.c  </p><p>1）首先修改GUIConf.h，将其修改为如下图所示</p><p><img src="https://i.imgur.com/e3BuHXn.png" alt></p><p>2）修改LCDConf.h  </p><p><img src="https://i.imgur.com/IzHISp9.png" alt></p><p>3）修改LCDDummy.c（LCDDriver下有三个文件都是模板，修改其中一个即可，我们以LCDDummy.c为例）主要是对函数进行优化</p><blockquote><p><strong>找到void LCD_L0_SetPixelIndex(int x, int y, int PixelIndex)，添加自己的画点函数</strong></p></blockquote><p><img src="https://i.imgur.com/0X2qTuG.png" alt></p><blockquote><p><strong>找到unsigned int LCD_L0_GetPixelIndex(int x, int y)，添加自己的读点函数</strong></p></blockquote><p><img src="https://i.imgur.com/5y8JHbF.png" alt></p><p>在这里主要优化以上两个函数，大家可以根据自己的需要自行优化<br>注意，下面这句话需要注释掉，不然文件不会编译，同时需要include ”ili93xx.h“</p><p><img src="https://i.imgur.com/PG528ek.png" alt></p><p>经过以上几布的移植，UCGUI已经可以使用了（不包括触摸屏）。  </p><h1 id="移植触摸屏"><a href="#移植触摸屏" class="headerlink" title="移植触摸屏"></a>移植触摸屏</h1><p>1.准备好触摸屏的驱动文件（本人用的是touch.c 和touch.h），添加到工程中。<br>2.将Sample\GUI_X中的GUI_X_Touch.c复制粘贴到Config中，再添加到工程中。<br>3.在GUIConf.h下修改。       </p><pre><code class="C"><span class="meta">#<span class="meta-keyword">define</span> GUI_SUPPORT_TOUCH         (1) </span></code></pre><p>4.接下来需要配置几个文件，首先是:<br> 1）GUITouchConf.h<br><img src="https://i.imgur.com/w4T4l3e.png" alt>  </p><p>GUI_TOUCH_AD_LEFT, GUI_TOUCH_AD_RIGHT, GUI_TOUCH_AD_TOP, GUI_TOUCH_AD_BOTTOM 这四个的值需要实测，测量方法自行百度。  </p><p> 2）GUI_X_Touch.c<br><img src="https://i.imgur.com/DZ72dzc.png" alt><br>上图4个函数前两个无需配置，按上图形式在后两个函数中添加你的读X轴，读Y轴函数TPReadX( )，TPReadY( )  </p><p>5.由于我们没有移植UC/OSII，不支持任务，所以需要靠定时刷新GUI_TOUCH_Exec( ) 这个函数，驱动函数获取坐标值重绘窗口，方法是在定时器中断TIMx_IRQHandler中加入GUI_TOUCH_Exec( )，GUI_Exec( )，实现坐标获取（添加timer.c和timer.h）<br><img src="https://i.imgur.com/nCgCHvs.png" alt></p><p>6.经过以上几步，触摸屏移植完成 注意：触摸屏初始化SPI_Config( )要在定时器初始化TIM6_Int_Init(99,7199)前，不然会白屏。  </p><p>完结。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 这是大二暑假学习STM32时写的一篇的教程，当初移植的时候耗费了好大的力气，集齐了万千网友的智慧和教程，归纳总结整理出来的，在此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="UCGUI" scheme="https://lxzzzzzxl.github.io/categories/UCGUI/"/>
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/categories/UCGUI/STM32/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
      <category term="UCGUI" scheme="https://lxzzzzzxl.github.io/tags/UCGUI/"/>
    
  </entry>
  
  <entry>
    <title>4*4矩阵键盘的扫描原理（附STM32代码）</title>
    <link href="https://lxzzzzzxl.github.io/2019/01/23/4x4%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E7%9A%84%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86%EF%BC%88%E9%99%84STM32%E4%BB%A3%E7%A0%81%EF%BC%89/"/>
    <id>https://lxzzzzzxl.github.io/2019/01/23/4x4矩阵键盘的扫描原理（附STM32代码）/</id>
    <published>2019-01-23T10:12:19.000Z</published>
    <updated>2019-01-28T10:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大二下的时候，刚学32没两个星期就热血膨胀去做项目，做的是一个简易的函数信号发生器（过段时间整理下也放到博客上来），里头要用到矩阵键盘，就上淘宝买了个来摸索，半天愣是没整明白，就找师兄要了份代码，那时候我的C语言水平就只是在scanf，printf阶段，死活没看懂，死活不理解，然后也就那么套上去用了；后来慢慢学习磨练，代码敲得多一些，回过头去看，才把这个东西给领悟了，下面我就来讲一讲4*4矩阵键盘的扫描原理，给有需要的人看看，自己也算是一个巩固。  </p><a id="more"></a>  <h1 id="4-4矩阵键盘的扫描原理"><a href="#4-4矩阵键盘的扫描原理" class="headerlink" title="4*4矩阵键盘的扫描原理"></a>4*4矩阵键盘的扫描原理</h1><p>先上一副4*4矩阵键盘的原理图<br><img src="https://i.imgur.com/qgfBzQd.png" alt> </p><p>首先要说明的一点，矩阵键盘的动态扫描略显复杂，不可能就是读一个端口数据，然后马上就出来结果。这需要对依次每一行（或每一列）的按键进行扫描、判断，然后得出结果。<br>从原理图我们可以看出，4行每行串联接分别接到PA4-PA7，4列每列串联分别接到PA0-PA3；设置PA0-PA3为输入模式，设置PA4-PA7为输出模式;<br>如上图所示，先扫描第一行，也就是S1,S2,S3,S4四个按键的状态，我们在PA口输入0xEF（二进制1110 1111），假设这个时候S1被按下了，会出现什么情况？因为PA4是低电平，S1被按下之后S1导通，导致PA0的电平从1降到0，于是PA端口的数据就变成了1110 1110，换算成16进制就是0XEE。于是我们知道S1被按下了。同理，S2,S3,S4被按下也有对应的16进制值，就这样循环每一行扫描，就可以知道16个按键哪个被按下。<br>下面附上一段STM32的源代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按键初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//IO初始化</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//使能PORTA时钟</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">//设置成上拉输入</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化输入</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">//输出</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 num = <span class="number">16</span>;  <span class="comment">//num用来存放当前按下的按键，当前赋值一个与处理无关的数，不让函数误操作</span></span><br><span class="line">u32 a = <span class="number">0</span>;    <span class="comment">//a用来存放按下后处理的数据a = a*10+num;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描按键程序</span></span><br><span class="line"><span class="function">u8 <span class="title">getkey</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> u8 keycode;        </span><br><span class="line"> u8 scancode;</span><br><span class="line"> u8 i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> scancode = <span class="number">0x10</span>;     <span class="comment">//行扫描</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line"> &#123;  </span><br><span class="line">GPIO_Write(GPIOA, ~scancode);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>((GPIO_ReadInputData(GPIOA)&amp;<span class="number">0x0f</span>) != <span class="number">0x0f</span>)</span><br><span class="line">&#123;</span><br><span class="line"> keycode = GPIO_ReadInputData(GPIOA); <span class="comment">//读出的列值</span></span><br><span class="line"> <span class="keyword">while</span>((GPIO_ReadInputData(GPIOA)&amp;<span class="number">0x0f</span>) != <span class="number">0x0f</span>) <span class="comment">//等待按键松开</span></span><br><span class="line"> &#123;</span><br><span class="line"> ;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;  </span><br><span class="line">scancode &lt;&lt;= <span class="number">1</span>;    <span class="comment">//循环扫描</span></span><br><span class="line"></span><br><span class="line">keycode &amp;= <span class="number">0x0f</span>;   <span class="comment">//有按键按下为0，0x0f，只考虑低四位的处理，低四位为输入</span></span><br><span class="line"><span class="keyword">switch</span>(keycode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0e</span>:          </span><br><span class="line"> num = <span class="number">4</span> * i + <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0d</span>:</span><br><span class="line"> num = <span class="number">4</span> * i + <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0b</span>:</span><br><span class="line"> num = <span class="number">4</span> * i + <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x07</span>:</span><br><span class="line"> num = <span class="number">4</span> * i + <span class="number">4</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line"> keycode = <span class="number">0xff</span>;   </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> num; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完结！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;大二下的时候，刚学32没两个星期就热血膨胀去做项目，做的是一个简易的函数信号发生器（过段时间整理下也放到博客上来），里头要用到矩阵键盘，就上淘宝买了个来摸索，半天愣是没整明白，就找师兄要了份代码，那时候我的C语言水平就只是在scanf，printf阶段，死活没看懂，死活不理解，然后也就那么套上去用了；后来慢慢学习磨练，代码敲得多一些，回过头去看，才把这个东西给领悟了，下面我就来讲一讲4*4矩阵键盘的扫描原理，给有需要的人看看，自己也算是一个巩固。  &lt;/p&gt;
    
    </summary>
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/categories/STM32/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>Modelsim 破解 注册</title>
    <link href="https://lxzzzzzxl.github.io/2019/01/22/Modelsim%20%E7%A0%B4%E8%A7%A3%20%E6%B3%A8%E5%86%8C/"/>
    <id>https://lxzzzzzxl.github.io/2019/01/22/Modelsim 破解 注册/</id>
    <published>2019-01-22T15:12:19.000Z</published>
    <updated>2019-01-28T10:19:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Mentor公司的ModelSim是工业界最优秀的语言仿真器，它支持Windows和Linux系统，是单一内核支持VHDL和Verilog混合仿真的仿真器。它采用直接优化的编译技术、单一内核仿真，不仅编译仿真速度业界最快、编译的代码与平台无关，而且便于保护IP核。它还提供了最友好的调试环境，具有个性化的图形界面和用户接口，为用户加快调试提供强有力的手段，它是FPGA/ASIC设计的首选仿真软件。<br>然而，学生党要用Modelsim，同样需要破解一下，下面还是搬砖网友的破解教程……  </p><a id="more"></a><h1 id="破解开始"><a href="#破解开始" class="headerlink" title="破解开始"></a>破解开始</h1><p>如果你没有破解，打开软件是这样的…<br><img src="https://i.imgur.com/WkI2cMO.jpg" width="300">  </p><blockquote><p><strong>注意：操作之前请先关闭Modelsim软件</strong>  </p></blockquote><p>1）点击下载附件modelsim_crack.zip，解压。<a href="/download/modelsim_crack.zip">点击下载</a> 解压后的文件列表如下：<br><img src="https://i.imgur.com/crBsa9L.jpg" alt></p><p>2）进入Modelsim的软件安装目录（我的电脑的安装目录是D:\modeltech64_10.4\win64）文件夹下找到mgls64.dll文件，去掉只读属性，如下图所示：<br><img src="https://i.imgur.com/NARM3Ew.jpg" alt></p><p>3）将解压后的文件MentorKG.exe和patch_dll.bat复制到Modelsim软件安装目录下的win64文件夹（我的电脑的安装目录是D:\modeltech64_10.4\win64）  </p><p>4）运行patch_dll.bat，稍等一段时间后即可生成一个TXT文本，如下图所示：<br><img src="https://i.imgur.com/kva33Nc.jpg" alt></p><p>5）将生成的TXT文本另存为LICENSE.TXT，另存的路径选择Modelsim软件的安装路径win64文件夹（我的电脑的安装目录是D:\modeltech64_10.4\win64）  </p><p>6）恢复mgls64.dll文件的只读属性  </p><p>7）接下来设置环境变量，在电脑桌面上点击“我的电脑”或“计算机”，右键选择【属性】，点击选择【高级系统设置】，进入下图所示界面：<br><img src="https://i.imgur.com/fPAxCvb.jpg" alt></p><p>8）选择“高级”选项卡下的【环境变量】，进入下图所示界面：<br><img src="https://i.imgur.com/OdVLjz8.jpg" alt></p><p>9）Windows环境变量有用户变量和系统变量两个环境变量，这里设置用户变量即可；如果最后使用不了，再以同样的方式设置系统变量。<br>点击【新建(N)】，打开编辑用户变量对话框，变量名命名为MGLS_LICENSE_FILE，变量值为刚才生成的LICENSE.TXT的文件路径，即D:\modeltech64_10.4\win64\LICENSE.TXT，点击【确定】，如下图所示：<br><img src="https://i.imgur.com/O10fMjw.jpg" alt></p><p>10）环境变量设置完成之后，点击三次【确定】按钮，返回电脑桌面即可设置完成。此时双击桌面上的Modelsim软件，可以进入，如下图所示：<br><img src="https://i.imgur.com/TzMP9s3.jpg" alt>  </p><p>操作完成。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Mentor公司的ModelSim是工业界最优秀的语言仿真器，它支持Windows和Linux系统，是单一内核支持VHDL和Verilog混合仿真的仿真器。它采用直接优化的编译技术、单一内核仿真，不仅编译仿真速度业界最快、编译的代码与平台无关，而且便于保护IP核。它还提供了最友好的调试环境，具有个性化的图形界面和用户接口，为用户加快调试提供强有力的手段，它是FPGA/ASIC设计的首选仿真软件。&lt;br&gt;然而，学生党要用Modelsim，同样需要破解一下，下面还是搬砖网友的破解教程……  &lt;/p&gt;
    
    </summary>
    
      <category term="Modelsim" scheme="https://lxzzzzzxl.github.io/categories/Modelsim/"/>
    
      <category term="FPGA" scheme="https://lxzzzzzxl.github.io/categories/Modelsim/FPGA/"/>
    
    
      <category term="Modelsim" scheme="https://lxzzzzzxl.github.io/tags/Modelsim/"/>
    
      <category term="FPGA" scheme="https://lxzzzzzxl.github.io/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>Quartus II 13.1破解 注册</title>
    <link href="https://lxzzzzzxl.github.io/2019/01/22/Quartus%20II%2013.1%E7%A0%B4%E8%A7%A3%20%E6%B3%A8%E5%86%8C/"/>
    <id>https://lxzzzzzxl.github.io/2019/01/22/Quartus II 13.1破解 注册/</id>
    <published>2019-01-21T18:12:19.000Z</published>
    <updated>2019-01-28T10:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 最近在入门FPGA（继续支持正点原子，用的是正点的新起点FPGA），打算跟STM32来个相辅相成，也算是多掌握一个东西，软件用的是Quartus II 13.1版本，编译程序发现没法生成烧录文件，研究了一下原来是没有license……，解决方法是：1.购买正版license； 2.破解； 自己是学生，买不起正版，这里搬一下网友的破解方法，哈哈哈，但还是希望有能力的支持一下正版。  </p><a id="more"></a> <h1 id="破解开始"><a href="#破解开始" class="headerlink" title="破解开始"></a>破解开始</h1><blockquote><p><strong>注意：操作之前请先关闭Quartus软件</strong>  </p></blockquote><p>1）点击下载附件keygen.zip，解压。<a href="/download/Keygen.zip">点击下载</a> 解压后的文件列表如下：<img src="http://www.openedv.com/data/attachment/forum/201807/27/105735hsru638b1utwufrb.jpg" alt>  </p><p>2）对于64位操作系统的电脑，将”Keygen_Quartus_II_13.1_x64.exe”拷贝到Quartus软件的安装目录: D:\altera\13.1\quartus\bin64路径下，并双击打开；<br>对于32位操作系统的电脑，将”Keygen_Quartus_II_13.1_x86.exe”拷贝到Quartus软件的安装目录: D:\altera\13.1\quartus\bin路径下，并双击打开。<br> <img src="https://i.imgur.com/jQe02ti.png" alt><br>点击应用按钮，然后选择license.dat的保存路径，这里将它保存在软件的安装目录: D:\altera\13.1目录下;  </p><p>3)打开Quartus软件，选择第二个选项，“Continue the 30-day evaluation period with no license file”(试用三十天);</p><p>4)点击Quartus软件菜单栏Tools→License Setup，调出注册管理界面；</p><p>5)复制NetWork Interface Card(NIC) ID一栏中的其中一个地址<br><img src="https://i.imgur.com/3ETPxIr.jpg" alt>  </p><p>6)找到前面保存在安装路径下的D:\altera\13.1文件夹下的“license.dat”，用记事本打开，然后将里面的“XXXXXXXXXXXX”替换为之前复制的内容(共两处)。<br><img src="https://i.imgur.com/7Tw197w.jpg" alt><br><img src="https://i.imgur.com/uXO3fV4.jpg" alt>  </p><p>7)返回Quartus软件License Setup界面，在License file栏设置license.dat文件路径，可以看到软件注册成功。<br><img src="https://i.imgur.com/YmKUo7s.jpg" alt>  </p><blockquote><p><strong>注意：Quartus II软件的安装路径一定不能包含中文、空格或者其它一些特殊的符号；</strong></p></blockquote><p> 完结。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 最近在入门FPGA（继续支持正点原子，用的是正点的新起点FPGA），打算跟STM32来个相辅相成，也算是多掌握一个东西，软件用的是Quartus II 13.1版本，编译程序发现没法生成烧录文件，研究了一下原来是没有license……，解决方法是：1.购买正版license； 2.破解； 自己是学生，买不起正版，这里搬一下网友的破解方法，哈哈哈，但还是希望有能力的支持一下正版。  &lt;/p&gt;
    
    </summary>
    
      <category term="Quartus II" scheme="https://lxzzzzzxl.github.io/categories/Quartus-II/"/>
    
      <category term="FPGA" scheme="https://lxzzzzzxl.github.io/categories/Quartus-II/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://lxzzzzzxl.github.io/tags/FPGA/"/>
    
      <category term="Quartus II" scheme="https://lxzzzzzxl.github.io/tags/Quartus-II/"/>
    
  </entry>
  
  <entry>
    <title>W600+STM32 AT指令(W600TCP服务器——用手机TCP调试助手发信息给单片机控制LED亮灭)</title>
    <link href="https://lxzzzzzxl.github.io/2019/01/20/W600+STM32%20AT%E6%8C%87%E4%BB%A4(W600TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E7%94%A8%E6%89%8B%E6%9C%BATCP%E8%B0%83%E8%AF%95%E5%8A%A9%E6%89%8B%E5%8F%91%E4%BF%A1%E6%81%AF%E7%BB%99%E5%8D%95%E7%89%87%E6%9C%BA%E6%8E%A7%E5%88%B6LED%E4%BA%AE%E7%81%AD)/"/>
    <id>https://lxzzzzzxl.github.io/2019/01/20/W600+STM32 AT指令(W600TCP服务器——用手机TCP调试助手发信息给单片机控制LED亮灭)/</id>
    <published>2019-01-20T07:59:39.000Z</published>
    <updated>2019-01-28T10:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 好些天没有更新博客，是因为学习新知识去了，学习了如何用单片机发信息给W600模组，并利用W600的响应控制单片机上的LED的亮灭，下面把我学习的成果以及过程中遇到的一些问题记录下来，作为备忘，也分享给有需要的人。废话不多说，我们进入正题…<br> 首先，我们需要梳理一下我们整个流程的思路：我们是通过单片机（STM32）的串口发送AT指令给wifi模块（这个是跟我们前面用串口调试助手是一个性质的）；紧接着，我们同样需要利用串口接收wifi模块返回的响应信息，对响应的信息进行判断，做出正确的反应。<br> 整个流程大致可以归纳为以上的那么一段话，接下来我们就根据具体代码来仔细讲解，代码不复杂，我写代码都是怎么简单怎么来，所以相信大家都可以看的懂。<br><a id="more"></a></p><h1 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h1><h2 id="串口初始化"><a href="#串口初始化" class="headerlink" title="串口初始化"></a>串口初始化</h2><p> 用的是串口2收发信息，硬件上将串口2的TX,RX跟模组的RX,TX连接，下面贴上代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">u8 USART2_RX_BUF[USART2_REC_LEN];  <span class="comment">//定义接收缓存数组(串口接受的数据存储在数组里)</span></span><br><span class="line">u16 USART2_RX_STA=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;  <span class="comment">//串口接收标志位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W600_USART_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStrue;     <span class="comment">//结构体定义</span></span><br><span class="line">USART_InitTypeDef USART_InitStrue;</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStrue;</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);  <span class="comment">//使能串口2，GPIOA时钟 </span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); </span><br><span class="line"><span class="comment">//GPIOA初始化</span></span><br><span class="line">GPIO_InitStrue.GPIO_Pin = GPIO_Pin_2;          <span class="comment">//USART2_TX    PA.2</span></span><br><span class="line">   GPIO_InitStrue.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">   GPIO_InitStrue.GPIO_Mode = GPIO_Mode_AF_PP;   <span class="comment">//复用推挽输出</span></span><br><span class="line">   GPIO_Init(GPIOA, &amp;GPIO_InitStrue);             <span class="comment">//初始化PA2</span></span><br><span class="line">    </span><br><span class="line">   GPIO_InitStrue.GPIO_Pin = GPIO_Pin_3;             <span class="comment">//USART2_RX  PA.3</span></span><br><span class="line">   GPIO_InitStrue.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//浮空输入</span></span><br><span class="line">   GPIO_Init(GPIOA, &amp;GPIO_InitStrue);                <span class="comment">//初始化PA3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//USART初始化</span></span><br><span class="line">USART_InitStrue.USART_BaudRate = <span class="number">115200</span>;<span class="comment">//波特率</span></span><br><span class="line">USART_InitStrue.USART_WordLength = USART_WordLength_8b;<span class="comment">//字长为8位数据格式</span></span><br><span class="line">USART_InitStrue.USART_StopBits = USART_StopBits_1;<span class="comment">//一个停止位</span></span><br><span class="line">USART_InitStrue.USART_Parity = USART_Parity_No;<span class="comment">//无奇偶校验位</span></span><br><span class="line">USART_InitStrue.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//无硬件数据流控制</span></span><br><span class="line">USART_InitStrue.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;<span class="comment">//收发模式</span></span><br><span class="line">USART_Init(USART2, &amp;USART_InitStrue); <span class="comment">//初始化串口</span></span><br><span class="line"></span><br><span class="line">NVIC_InitStrue.NVIC_IRQChannel = USART2_IRQn;</span><br><span class="line">NVIC_InitStrue.NVIC_IRQChannelPreemptionPriority=<span class="number">3</span> ;<span class="comment">//抢占优先级3</span></span><br><span class="line">NVIC_InitStrue.NVIC_IRQChannelSubPriority = <span class="number">3</span>;<span class="comment">//子优先级3</span></span><br><span class="line">NVIC_InitStrue.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//IRQ通道使能</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStrue);<span class="comment">//根据指定的参数初始化VIC寄存器</span></span><br><span class="line">USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);<span class="comment">//开启中断</span></span><br><span class="line"></span><br><span class="line">USART_Cmd(USART2,ENABLE);   <span class="comment">//使能串口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*************************串口2中断服务函数*********************************//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>                <span class="comment">//串口2中断服务程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART2, USART_IT_RXNE)!=RESET)  </span><br><span class="line">&#123;  </span><br><span class="line"> flag=<span class="number">1</span>;</span><br><span class="line">   USART2_RX_BUF[USART2_RX_STA++]=USART_ReceiveData(USART2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 上面这段代码没什么特别的，就是串口的初始化，重点看一下中断服务函数，我们的信息接收是在中断中进行的，原本用的是正点原子的，但是却一直收不到数据，弄了很久才发现问题在于原子定义的协议，协议规定了接收到回车换行代表数据接收完成，但恰恰我用的wifi模块返回的信息是回车换行开头的……，所以我修改成没有任何协议，只要接收到数据就统统存储到前面定义的数组中。  </p><h2 id="WiFi模块初始化"><a href="#WiFi模块初始化" class="headerlink" title="WiFi模块初始化"></a>WiFi模块初始化</h2><p> 说是模块的初始化，实际上模块没有什么要初始化的，硬件连接上去就可以收发数据，我们在这里做的就是编写单片机发送AT指令给模块配置AP模式的函数，直接贴代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*******************预定义字符串*****************************//</span></span><br><span class="line"><span class="keyword">char</span> w600_rst[]=<span class="string">"AT+RST\r\n"</span>; <span class="comment">//复位指令</span></span><br><span class="line"><span class="keyword">char</span> w600_at[]=<span class="string">"AT\r\n"</span>; <span class="comment">//握手连接指令</span></span><br><span class="line"><span class="keyword">char</span> w600_cwmode1[]=<span class="string">"AT+CWMODE=1\r\n"</span>; <span class="comment">//设置w600工作模式为STA </span></span><br><span class="line"><span class="keyword">char</span> w600_cwmode2[]=<span class="string">"AT+CWMODE=2\r\n"</span>; <span class="comment">//设置w600工作模式为AP </span></span><br><span class="line"><span class="keyword">char</span> w600_cwjap[]=<span class="string">"AT+CWJAP=\"USER_1A383A\",\"00000000\"\r\n"</span>; <span class="comment">//设置要加入的AP参数 </span></span><br><span class="line"><span class="keyword">char</span> w600_cwsap[]=<span class="string">"AT+CWSAP=\"lxz\",\"lxz333333\",5,3\r\n"</span>; <span class="comment">//设置要创建的AP参数</span></span><br><span class="line"><span class="keyword">char</span> w600_cipmux[]=<span class="string">"AT+CIPMUX=1\r\n"</span>; <span class="comment">//使能多链接 </span></span><br><span class="line"><span class="keyword">char</span> w600_cipserver[]=<span class="string">"AT+CIPSERVER=1,6000\r\n"</span>; <span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">char</span> w600_return[]=<span class="string">"OK\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************字符串发送函数*****************************//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SendString</span><span class="params">(USART_TypeDef* USARTx,<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(*str!=<span class="string">'\0'</span>)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USARTx,USART_FLAG_TC )==RESET);</span><br><span class="line">USART_SendData(USARTx,*str);</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*************************数组清空函数**************************//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Data_Clear</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">600</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">USART2_RX_BUF[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*************************返回信息比较函数************************//</span></span><br><span class="line"> Data_Compare(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> strx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">600</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((USART2_RX_BUF[i]==<span class="string">'O'</span>)&amp;&amp;(USART2_RX_BUF[i+<span class="number">1</span>]==<span class="string">'K'</span>))</span><br><span class="line">&#123;</span><br><span class="line">  strx=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> strx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u8 <span class="title">Data_Compare1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> strx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">600</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((USART2_RX_BUF[i]==<span class="string">'S'</span>)&amp;&amp;(USART2_RX_BUF[i+<span class="number">1</span>]==<span class="string">'T'</span>))</span><br><span class="line">&#123;</span><br><span class="line">  strx=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u8 <span class="title">Data_Compare2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> strx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">600</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((USART2_RX_BUF[i]==<span class="string">'O'</span>)&amp;&amp;(USART2_RX_BUF[i+<span class="number">1</span>]==<span class="string">'N'</span>))</span><br><span class="line">&#123;</span><br><span class="line">  strx=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************W600初始化**************************//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W600_wifi_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">USART_SendString(USART2, w600_at);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Data_Compare()==<span class="number">1</span>) <span class="keyword">break</span>;     </span><br><span class="line">&#125;</span><br><span class="line">Data_Clear();</span><br><span class="line">WLED1=<span class="number">1</span>;</span><br><span class="line">delay_ms(<span class="number">500</span>);</span><br><span class="line">USART_SendString(USART2, w600_cwmode2);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Data_Compare()==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Data_Clear();</span><br><span class="line">WLED1=<span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">500</span>);</span><br><span class="line">USART_SendString(USART2, w600_cwsap);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Data_Compare()==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Data_Clear();</span><br><span class="line">WLED1=<span class="number">1</span>;</span><br><span class="line">delay_ms(<span class="number">500</span>);</span><br><span class="line">USART_SendString(USART2, w600_cipmux);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Data_Compare()==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Data_Clear();</span><br><span class="line">WLED1=<span class="number">0</span>;</span><br><span class="line">delay_ms(<span class="number">500</span>);</span><br><span class="line">USART_SendString(USART2, w600_cipserver);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Data_Compare()==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Data_Clear();</span><br><span class="line">WLED1=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这段代码有几个函数我们讲解一下，首先是数组清空函数<strong>void Data_Clear(void)</strong>，这个函数的作用是清空每一次我们接收的内容，为了下一次接收新的数据做准备，避免出错；还有一个就是返回信息比较函数<strong>Data_Compare(void)</strong>，因为我们每一次发送AT指令，模块都会返回响应信息，我们需要判断是否接收到正确的信息来确定是否发送新的AT指令；最后一个就是系列指令发送的函数了<strong>void W600_wifi_init(void)</strong>，这个函数我们通过系列指令来配置AP模式，使能多链接以及确定端口号…每发送一个指令，判断一次返回信息，这里还用LED亮灭来辅助观察，相信大家看代码是可以看的懂的。  </p><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>下面我们看看主函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">delay_init();     <span class="comment">//延时函数初始化  </span></span><br><span class="line">NVIC_Configuration();  <span class="comment">//设置NVIC中断分组2:2位抢占优先级，2位响应优先级</span></span><br><span class="line">uart_init(<span class="number">9600</span>); <span class="comment">//串口初始化为9600</span></span><br><span class="line">KEY_Init(); </span><br><span class="line">LED_Init();</span><br><span class="line">W600_USART_init();</span><br><span class="line">W600_wifi_init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Data_Compare1()==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Data_Clear();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Data_Compare2()==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Data_Clear();</span><br><span class="line">flag =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line"> flag =<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">600</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(USART2_RX_BUF[i]==<span class="string">'1'</span>  &amp;&amp; USART2_RX_BUF[i+<span class="number">1</span>]==<span class="string">':'</span>)</span><br><span class="line">      &#123;</span><br><span class="line"> <span class="keyword">switch</span>(USART2_RX_BUF[i+<span class="number">2</span>])</span><br><span class="line"> &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">'O'</span>: WLED2=<span class="number">1</span>;</span><br><span class="line">                         <span class="keyword">break</span>; </span><br><span class="line">               <span class="keyword">case</span> <span class="string">'F'</span>: WLED2=<span class="number">0</span>;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:  <span class="keyword">break</span>;       </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里头还用到了两个返回信息比较函数，因为我们手机连上热点和连接上对应端口，模块都会分别返回信息到串口，这里也要判断一下；最后我们再次讲解一下我们的串口中断服务函数，里头定义了每次接收到数据，标志位置1，前面我们不讲是因为我们没用到这个标志位，当我们手机TCP调试助手连接上模块后，我们的准备工作就算是做完了，这时将标志位置0，接下来就是等待发送亮灭等的信息了，这里我们定义循环接收信息，当发送亮灭等信号后串口接收到新的数据（也就是当标志位被置1），我们判断是要亮还是灭，然后做出正确响应。（亮时O，灭时F，这些都是我们自己可以定义修改的）。<br>好了，代码这样就讲解完了，大家实践试试吧，本片完结！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 好些天没有更新博客，是因为学习新知识去了，学习了如何用单片机发信息给W600模组，并利用W600的响应控制单片机上的LED的亮灭，下面把我学习的成果以及过程中遇到的一些问题记录下来，作为备忘，也分享给有需要的人。废话不多说，我们进入正题…&lt;br&gt; 首先，我们需要梳理一下我们整个流程的思路：我们是通过单片机（STM32）的串口发送AT指令给wifi模块（这个是跟我们前面用串口调试助手是一个性质的）；紧接着，我们同样需要利用串口接收wifi模块返回的响应信息，对响应的信息进行判断，做出正确的反应。&lt;br&gt; 整个流程大致可以归纳为以上的那么一段话，接下来我们就根据具体代码来仔细讲解，代码不复杂，我写代码都是怎么简单怎么来，所以相信大家都可以看的懂。&lt;br&gt;
    
    </summary>
    
      <category term="W600" scheme="https://lxzzzzzxl.github.io/categories/W600/"/>
    
      <category term="WiFi" scheme="https://lxzzzzzxl.github.io/categories/W600/WiFi/"/>
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/categories/W600/WiFi/STM32/"/>
    
      <category term="AT开发" scheme="https://lxzzzzzxl.github.io/categories/W600/WiFi/STM32/AT%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
      <category term="W600" scheme="https://lxzzzzzxl.github.io/tags/W600/"/>
    
      <category term="WiFi" scheme="https://lxzzzzzxl.github.io/tags/WiFi/"/>
    
  </entry>
  
</feed>
