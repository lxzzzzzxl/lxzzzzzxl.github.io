<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>霹雳大乌龙的学习笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lxzzzzzxl.github.io/"/>
  <updated>2019-10-11T06:08:12.973Z</updated>
  <id>https://lxzzzzzxl.github.io/</id>
  
  <author>
    <name>霹雳大乌龙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言 - 函数返回一个数组</title>
    <link href="https://lxzzzzzxl.github.io/2019/10/10/C%E8%AF%AD%E8%A8%80-%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84/"/>
    <id>https://lxzzzzzxl.github.io/2019/10/10/C语言-返回数组/</id>
    <published>2019-10-10T10:12:19.000Z</published>
    <updated>2019-10-11T06:08:12.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如下函数是否存在问题？如果存在问题如何修改？同时简要阐述涉及的相关概念。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetString</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello"</span>;   <span class="comment">//开辟一个能连续存放6个字符的数组，将“hello”字符串常量拷贝到数组中</span></span><br><span class="line">    <span class="keyword">return</span> str;             <span class="comment">//返回数组的起始地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单几行代码，一眼就可以看出：这是一个C语言返回数组的问题。<br><br>直接使用上述代码运行的话，相信你会看到下面这句警告：<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: function returns address of local variable</span><br></pre></td></tr></table></figure></p><p>意思就是说，函数返回的是局部变量的地址！那我们都知道，局部变量的内存在函数结束后会被释放掉，所以上述代码返回的数组起始地址也没有意义了，因为即使你给了我地址，我也找不到地址原本指向的东西了。<br><br>那么我们应该怎么做才能确保程序正常运行呢？我在网上看到有以下几种解决方式，我们一一验证一下：</p><blockquote><p>1.使用全局变量；<br><br>2.使用静态局部变量；<br><br>3.在函数内动态分配内存；<br><br>4.在函数调用参数中传入数组地址；<br></p></blockquote><h2 id="1-使用全局变量"><a href="#1-使用全局变量" class="headerlink" title="1.使用全局变量"></a>1.使用全局变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;   <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">GetString</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> = GetString();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用全局变量的方式是不是我上面写的那样我也不是很清楚，不过经验证该代码可行。</p><h2 id="2-使用静态局部变量"><a href="#2-使用静态局部变量" class="headerlink" title="2.使用静态局部变量"></a>2.使用静态局部变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">GetString</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> str[] = <span class="string">"hello"</span>;    <span class="comment">//静态局部变量</span></span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> = GetString();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经验证，该方法可行。</p><h2 id="3-在函数内动态分配内存"><a href="#3-在函数内动态分配内存" class="headerlink" title="3.在函数内动态分配内存"></a>3.在函数内动态分配内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">GetString</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="string">"hello"</span>)); <span class="comment">//动态数组的内存分配</span></span><br><span class="line">str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> = GetString();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种其实就是用指针传递数组，经验证可行。</p><h2 id="4-在函数调用参数中传入数组地址"><a href="#4-在函数调用参数中传入数组地址" class="headerlink" title="4.在函数调用参数中传入数组地址"></a>4.在函数调用参数中传入数组地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">GetString</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> = GetString(<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式我感觉是嵌入式开发比较常用的方法了，经验证可行！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;如下函数是否存在问题？如果存在问题如何修改？同时简要阐述涉及的相关概念。&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="C语言" scheme="https://lxzzzzzxl.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://lxzzzzzxl.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现基于RT-Thread的百度语音识别（一）</title>
    <link href="https://lxzzzzzxl.github.io/2019/10/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://lxzzzzzxl.github.io/2019/10/03/手把手教你实现基于RT-Thread的百度语音识别（一）/</id>
    <published>2019-10-03T10:12:19.000Z</published>
    <updated>2019-10-11T06:10:26.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手把手教你实现基于RT-Thread的百度语音识别（一）"><a href="#手把手教你实现基于RT-Thread的百度语音识别（一）" class="headerlink" title="手把手教你实现基于RT-Thread的百度语音识别（一）"></a>手把手教你实现基于RT-Thread的百度语音识别（一）</h1><h2 id="RT-Thread简介"><a href="#RT-Thread简介" class="headerlink" title="RT-Thread简介"></a>RT-Thread简介</h2><p>RT-Thread是一个集实时操作系统（RTOS）内核、中间件组件和开发者社区于一体的技术平台，由熊谱翔先生带领并集合开源社区力量开发而成，RT-Thread也是一个组件完整丰富、高度可伸缩、简易开发、超低功耗、高安全性的物联网操作系统。RT-Thread具备一个IoT OS平台所需的所有关键组件，例如GUI、网络协议栈、安全传输、低功耗组件等等。经过11年的累积发展，RT-Thread已经拥有一个国内最大的嵌入式开源社区，同时被广泛应用于能源、车载、医疗、消费电子等多个行业，累积装机量超过2亿台，成为国人自主开发、国内最成熟稳定和装机量最大的开源RTOS。</p><p>RT-Thread拥有良好的软件生态，支持市面上所有主流的编译工具如GCC、Keil、IAR等，工具链完善、友好，支持各类标准接口，如POSIX、CMSIS、C++应用环境、Javascript执行环境等，方便开发者移植各类应用程序。商用支持所有主流MCU架构，如ARM Cortex-M/R/A, MIPS, X86, Xtensa, C-Sky, RISC-V，几乎支持市场上所有主流的MCU和Wi-Fi芯片。</p><p>得益于RT-thread丰富的组件以及一系列好用的软件包，作为应用开发者，我们不必过度关心底层的实现，而可以将更多的精力放在应用实现上，我将分享的百度语音识别便是如此。</p><h2 id="百度AI简介"><a href="#百度AI简介" class="headerlink" title="百度AI简介"></a>百度AI简介</h2><p>语音识别服务是百度AI众多服务中的一项，应用该服务，你可以将语音识别为文字，适用于手机应用语音交互、语音内容分析、智能硬件、呼叫中心智能客服等多种场景。我分享的百度语音识别就是将该服务应用于STM32上的一个案例。</p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><blockquote><p>硬件：STM32 + 音频编解码芯片 + LCD + 常用外设（为了方便我直接使用正点原子的潘多拉开发板）<br><br>平台：RT-Thread + 百度AI</p></blockquote><p>1.使用RT-Thread的 ‘stm32l475-atk-pandora’ BSP（若你使用的硬件跟我不一样，可以使用RT-Thread对应的BSP，或根据官方教程自行制作）；<br><br>2.挂载elm FatFS文件系统，用于存放待识别音频；<br><br>3.初始化板载WIFI模块 AP6181 或 使用AT组件+ESP8266，使开发板具备网络功能；<br><br>4.使用Audio组件，实现录音功能，并将音频存入文件系统；<br><br>5.使用webclient软件包，将文件系统中的音频上传到百度AI服务端，识别后返回Json数据；<br><br>6.使用CJson软件包解析数据，根据解析出的数据作出响应动作（控制RGB灯）；<br><br>7.将中文字库烧写进外挂的spi flash，使用SUFD+FAL软件包读写flash，实现LCD的中文显示。<br></p><p>因为项目的重点以及难点在于百度语音识别，所以接下来的系列文章，我将着重讲解上述的4-7点，而其他部分大家自行前往RT-Thread的文档中心学习。</p><h2 id="百度语音识别服务使用流程"><a href="#百度语音识别服务使用流程" class="headerlink" title="百度语音识别服务使用流程"></a>百度语音识别服务使用流程</h2><p>在项目开始之前，我觉得有必要带大家走一遍百度语音服务的调用流程，不然直接写代码，肯定懵逼一大片。其实这部分我之前在我的个人博客也有简单写过，顺手打波广告（lxzzzzzxl.github.io）我的个人博客，不过太久没去看发现很多图挂了，应该是之前使用的图床有问题。废话不多说：</p><p>百度语音识别简单来说就是百度AI通过API的方式给开发者提供一个通用的HTTP接口，开发者通过这个接口上传音频文件，返回识别结果；</p><h2 id="首先我们要注册一个百度开发者账号，然后创建一个语音识别的应用："><a href="#首先我们要注册一个百度开发者账号，然后创建一个语音识别的应用：" class="headerlink" title="首先我们要注册一个百度开发者账号，然后创建一个语音识别的应用："></a>首先我们要注册一个百度开发者账号，然后创建一个语音识别的应用：</h2><p>1.搜索“百度AI”，进入如下页面，点击右上方控制台（未注册的需注册）：<br><img src="https://ftp.bmp.ovh/imgs/2019/10/105cd8bd45d5fe3b.png" alt></p><p>2.点击“语音技术”，进入如下页面，点击“创建应用”：<br><img src="https://ftp.bmp.ovh/imgs/2019/10/702a5db744a2bb28.png" alt></p><p>3.填写相关信息后点击创建，创建成功后可以在应用列表看到你新创建的应用：<br><img src="https://ftp.bmp.ovh/imgs/2019/10/35856dd41c1c0f9d.png" alt></p><h2 id="语音识别过程"><a href="#语音识别过程" class="headerlink" title="语音识别过程"></a>语音识别过程</h2><p>4.获取 Access Token：<br><br>（这里推荐一个软件：Postman，使用这个软件你可以在自己的PC上完整的体验整个百度语音识别过程）<br><br>向授权服务地址 <a href="https://aip.baidubce.com/oauth/2.0/token" target="_blank" rel="noopener">https://aip.baidubce.com/oauth/2.0/token</a> 发送请求（推荐使用POST），并在URL中带上以下参数：</p><blockquote><p>grant_type： 必须参数，固定为client_credentials；<br><br>client_id： 必须参数，应用的API Key；<br><br>client_secret： 必须参数，应用的Secret Key；<br></p></blockquote><p>使用浏览器，例：<br><br><a href="https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=Va5yQRHl********LT0vuXV4&amp;client_secret=" target="_blank" rel="noopener">https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=Va5yQRHl********LT0vuXV4&amp;client_secret=</a> 0rDSjzQ20XUj5i<strong><em>**</em></strong>PQSzr5pVw2&amp;</p><p>下图为使用Postman:<br><img src="https://ftp.bmp.ovh/imgs/2019/10/2394d316f2a8cc06.png" alt></p><p>5.使用Access Token进行语音识别（Content-Type必填 / body里放的是你自己的音频文件，需与Content-Type对应，可以下载官方样例）<br><img src="https://ftp.bmp.ovh/imgs/2019/10/259c4852d08d9d74.png" alt></p><p><img src="https://ftp.bmp.ovh/imgs/2019/10/9002b4cb9f67c6f0.png" alt></p><p><img src="https://ftp.bmp.ovh/imgs/2019/10/49e0b9bf2a4dcdd2.png" alt></p><p>更多详细内容，大家参考百度AI文档中心的相关部分<a href="https://ai.baidu.com/docs#/ASR-API/77e2b22e" target="_blank" rel="noopener">https://ai.baidu.com/docs#/ASR-API/77e2b22e</a> ，相信各位看完文档再来看这部分会豁然开朗~</p><p>本次的介绍就到这里了，说实在的写博客写推文比敲代码难多了，本人水平有限，表达或许有些难以明白，望多见谅~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;手把手教你实现基于RT-Thread的百度语音识别（一）&quot;&gt;&lt;a href=&quot;#手把手教你实现基于RT-Thread的百度语音识别（一）&quot; class=&quot;headerlink&quot; title=&quot;手把手教你实现基于RT-Thread的百度语音识别（一）&quot;&gt;&lt;/a&gt;手把
      
    
    </summary>
    
      <category term="语音识别" scheme="https://lxzzzzzxl.github.io/categories/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
      <category term="百度语音" scheme="https://lxzzzzzxl.github.io/tags/%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3/"/>
    
      <category term="RT-Thread" scheme="https://lxzzzzzxl.github.io/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现基于RT-Thread的百度语音识别（三）</title>
    <link href="https://lxzzzzzxl.github.io/2019/10/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://lxzzzzzxl.github.io/2019/10/03/手把手教你实现基于RT-Thread的百度语音识别（三）/</id>
    <published>2019-10-03T10:12:19.000Z</published>
    <updated>2019-10-11T06:10:36.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次我们还是先不实现录音功能，因为音频编解码这一块是比较有难度的，再加上RT-Thread的Audio设备也比较复杂，难以理解，我暂时没考虑好怎么讲解该部分（我自己也没理解透~），所以就放到后面再分享吧。那么这次我们就讲讲项目的第7点：</p><blockquote><p>将中文字库烧写进外挂的spi flash，使用SUFD+FAL软件包读写flash，实现LCD的中文显示，用来显示语音识别结果。</p></blockquote><p>原本我做项目时，是没有打算要在LCD上显示识别结果的，但是因为我使用的潘多拉开发板板载了一块1.3寸的240*240高分辨率TFTLCD显示屏，不把它用上岂不是浪费？再加上后面想到如果不用语音识别来控制外设，识别一些其他语音的时候，有个可以显示识别结果的屏幕，岂不美哉。于是乎我便开始整LCD显示了，不整不知道，一整头皮发麻，RT-Thread官方对于潘多拉开发板在驱动各方面的支持都已经做的非常好了，包括LCD驱动，但是却没有中文字库的支持，也没有相关的资料，所以我就只能自己想办法实现了。</p><p>下面我分享的内容，跟百度语音识别没有太大的关系，主要是如何在LCD上显示中文的内容，但百度语音确确实实给我在实现的路上埋下了许多坑，所以我觉得这部分还是很有必要分享的，究竟是怎么一回事，听我细细道来。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>首先你必须完成了系列文章（二）中讲解的内容；</li><li>阅读正点原子教程中SPI Flash和汉字显示两个例程，确保你清楚汉字显示原理，如何制作字库，如何将字库烧写进flash中；</li><li>准备好中文字库；</li></ol><h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h2><p>嘻嘻~还是为了方便，字库嘛，我使用正点原子裸机例程提供的中文字库（该字库包含了12，16，24，32四种字体大小的字库），然后运行汉字显示例程的程序，该程序里包含将字库烧写进spi flash的部分，我们要的就是这个部分，其实你可以自己编程实现flash读写（so easy !），自行烧写字库，但是为了方便我就偷懒了，毕竟只要字库不损坏，咱也就烧这一次。</p><p>上面部分你可以裸机实现，无所谓，只要将字库烧进flash（我这里是W25Q128）就行了。下面重头戏来了（再次确保你已经明白了汉字显示原理），这次我们又用到了RT-Thread的两个软件包：SUFD和FAL，简单介绍一下：</p><h3 id="SUFD（串行闪存通用驱动库）"><a href="#SUFD（串行闪存通用驱动库）" class="headerlink" title="SUFD（串行闪存通用驱动库）"></a>SUFD（串行闪存通用驱动库）</h3><p>看中文名就知道了，用来驱动spi flash的嘛。SFUD是一种开源的串行SPI Flash通用驱动库（是RT-Thread的armink大神开发的，大佬！），使用这个库，你就不必自己编写flash驱动了，基本市面上绝大多数的flash，都可以轻轻松松地给你驱起来。</p><h3 id="FAL（Flash抽象层）"><a href="#FAL（Flash抽象层）" class="headerlink" title="FAL（Flash抽象层）"></a>FAL（Flash抽象层）</h3><p>简单来说，使用该软件包，你可以方便地使用API对flash进行分区管理，读写操作等，支持自定义分区表（不得不说，强！）。</p><h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>好了，同样，使用ENV工具把SUFD和FAL添加进工程中，开始写代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********</span></span><br><span class="line"><span class="comment">cn_font.c</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;drv_qspi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;drv_spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;drv_lcd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cn_font.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">结构体名称 ： _font_info</span></span><br><span class="line"><span class="comment">定    义 ：</span></span><br><span class="line"><span class="comment">    __packed typedef struct</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        uint8_t fontok;//字库存在标志，0XAA，字库正常；其他，字库不存在</span></span><br><span class="line"><span class="comment">        uint32_t ugbkaddr; //unigbk的地址</span></span><br><span class="line"><span class="comment">        uint32_t ugbksize;//unigbk的大小</span></span><br><span class="line"><span class="comment">        uint32_t f12addr;//gbk12地址</span></span><br><span class="line"><span class="comment">        uint32_t gbk12size;//gbk12的大小</span></span><br><span class="line"><span class="comment">        uint32_t f16addr;//gbk16地址</span></span><br><span class="line"><span class="comment">        uint32_t gbk16size;//gbk16的大小</span></span><br><span class="line"><span class="comment">        uint32_t f24addr;//gbk24地址</span></span><br><span class="line"><span class="comment">        uint32_t gbk24size;//gbk24的大小</span></span><br><span class="line"><span class="comment">        uint32_t f32addr;//gbk32地址</span></span><br><span class="line"><span class="comment">        uint32_t gbk32size;//gbk32的大小</span></span><br><span class="line"><span class="comment">    &#125; _font_info;</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br><span class="line">_font_info ftinfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从字库中找出字模 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_hz_mat</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *code, <span class="keyword">unsigned</span> <span class="keyword">char</span> *mat, <span class="keyword">uint8_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ftinfo.ugbkaddr = <span class="number">0x0000000</span>+<span class="keyword">sizeof</span>(ftinfo);</span><br><span class="line">ftinfo.ugbksize = <span class="number">174344</span>;</span><br><span class="line">ftinfo.f12addr = <span class="number">0x0002A908</span>+<span class="keyword">sizeof</span>(ftinfo);</span><br><span class="line">ftinfo.gbk12size = <span class="number">574560</span>;</span><br><span class="line">ftinfo.f16addr = <span class="number">0x000B6D68</span>+<span class="keyword">sizeof</span>(ftinfo);</span><br><span class="line">ftinfo.gbk16size = <span class="number">766080</span>;</span><br><span class="line">ftinfo.f24addr = <span class="number">0x00171DE8</span>+<span class="keyword">sizeof</span>(ftinfo);</span><br><span class="line">ftinfo.gbk24size = <span class="number">1723680</span>;</span><br><span class="line">ftinfo.f32addr = <span class="number">0x00316B08</span>+<span class="keyword">sizeof</span>(ftinfo);</span><br><span class="line">ftinfo.gbk32size = <span class="number">3064320</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> qh, ql;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> foffset;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_partition</span> *<span class="title">partition</span> = <span class="title">fal_partition_find</span>("<span class="title">font</span>");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> csize = (size / <span class="number">8</span> + ((size % <span class="number">8</span>) ? <span class="number">1</span> : <span class="number">0</span>)) * (size); <span class="comment">//得到字体一个字符对应点阵集所占的字节数</span></span><br><span class="line">qh =*code;</span><br><span class="line">ql = *(++code);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(qh &lt; <span class="number">0x81</span> || ql &lt; <span class="number">0x40</span> || ql == <span class="number">0xff</span> || qh == <span class="number">0xff</span>) <span class="comment">//非常用汉字</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; csize; i++)*mat++ = <span class="number">0x00</span>; <span class="comment">//填充满格</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//结束访问</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(ql &lt; <span class="number">0x7f</span>)ql -= <span class="number">0x40</span>; <span class="comment">//注意!</span></span><br><span class="line">    <span class="keyword">else</span> ql -= <span class="number">0x41</span>;</span><br><span class="line"></span><br><span class="line">    qh -= <span class="number">0x81</span>;</span><br><span class="line">    foffset = ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">190</span> * qh + ql) * csize;<span class="comment">//得到字库中的字节偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">fal_partition_read(partition, foffset + ftinfo.f12addr, mat, csize);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            fal_partition_read(partition, foffset + ftinfo.f16addr, mat, csize);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">24</span>:</span><br><span class="line">            fal_partition_read(partition, foffset + ftinfo.f24addr, mat, csize);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">            fal_partition_read(partition, foffset + ftinfo.f32addr, mat, csize);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示一个指定大小的汉字 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_font</span><span class="params">(<span class="keyword">uint16_t</span> x, <span class="keyword">uint16_t</span> y, <span class="keyword">uint8_t</span> *font, <span class="keyword">uint8_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint16_t</span> colortemp;</span><br><span class="line">    <span class="keyword">uint8_t</span> sta;</span><br><span class="line">    <span class="keyword">uint8_t</span> temp, t, t1;</span><br><span class="line">    <span class="keyword">uint8_t</span> dzk[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> csize = (size / <span class="number">8</span> + ((size % <span class="number">8</span>) ? <span class="number">1</span> : <span class="number">0</span>)) * (size);<span class="comment">//得到字体一个字符对应点阵集所占的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size != <span class="number">12</span> &amp;&amp; size != <span class="number">16</span> &amp;&amp; size != <span class="number">24</span> &amp;&amp; size != <span class="number">32</span>)<span class="keyword">return</span>;<span class="comment">//不支持的size</span></span><br><span class="line"></span><br><span class="line">    get_hz_mat(font, dzk, size);<span class="comment">//得到相应大小的点阵数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((size == <span class="number">16</span>) || (size == <span class="number">24</span>) || (size == <span class="number">32</span>))<span class="comment">//16、24、32号字体</span></span><br><span class="line">    &#123;</span><br><span class="line">        sta = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        lcd_address_set(x, y, x + size - <span class="number">1</span>, y + size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; csize; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = dzk[t];<span class="comment">//得到点阵数据</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(t1 = <span class="number">0</span>; t1 &lt; sta; t1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &amp; <span class="number">0x80</span>) colortemp = <span class="number">0x0000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> colortemp = <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">                lcd_write_half_word(colortemp);</span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size == <span class="number">12</span>)<span class="comment">//12号字体</span></span><br><span class="line">    &#123;</span><br><span class="line">        lcd_address_set(x, y, x + size - <span class="number">1</span>, y + size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; csize; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = dzk[t];<span class="comment">//得到点阵数据</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t % <span class="number">2</span> == <span class="number">0</span>)sta = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> sta = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(t1 = <span class="number">0</span>; t1 &lt; sta; t1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &amp; <span class="number">0x80</span>) colortemp = <span class="number">0x0000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> colortemp = <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">                lcd_write_half_word(colortemp);</span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在指定位置开始显示一个字符串 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_str</span><span class="params">(<span class="keyword">uint16_t</span> x, <span class="keyword">uint16_t</span> y, <span class="keyword">uint16_t</span> width, <span class="keyword">uint16_t</span> height, <span class="keyword">uint8_t</span> *str, <span class="keyword">uint8_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint16_t</span> x0 = x;</span><br><span class="line">    <span class="keyword">uint16_t</span> y0 = y;</span><br><span class="line">    <span class="keyword">uint8_t</span> bHz = <span class="number">0</span>;   <span class="comment">//字符或者中文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="number">0</span>) <span class="comment">//数据未结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!bHz)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str &gt; <span class="number">0x80</span>)bHz = <span class="number">1</span>; <span class="comment">//中文</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>              <span class="comment">//字符</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x &gt; (x0 + width - size / <span class="number">2</span>)) <span class="comment">//换行</span></span><br><span class="line">                &#123;</span><br><span class="line">                    y += size;</span><br><span class="line">                    x = x0;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(y &gt; (y0 + height - size))<span class="keyword">break</span>; <span class="comment">//越界返回</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(*str == <span class="number">13</span>) <span class="comment">//换行符号</span></span><br><span class="line">                &#123;</span><br><span class="line">                    y += size;</span><br><span class="line">                    x = x0;</span><br><span class="line">                    str++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> lcd_show_char(x, y, *str, size); <span class="comment">//有效部分写入</span></span><br><span class="line"></span><br><span class="line">                str++;</span><br><span class="line">                x += size / <span class="number">2</span>; <span class="comment">//字符,为全字的一半</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//中文</span></span><br><span class="line">        &#123;</span><br><span class="line">            bHz = <span class="number">0</span>; <span class="comment">//有汉字库</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x &gt; (x0 + width - size)) <span class="comment">//换行</span></span><br><span class="line">            &#123;</span><br><span class="line">                y += size;</span><br><span class="line">                x = x0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(y &gt; (y0 + height - size))<span class="keyword">break</span>; <span class="comment">//越界返回</span></span><br><span class="line"></span><br><span class="line">            show_font(x, y, str, size); <span class="comment">//显示这个汉字,空心显示</span></span><br><span class="line">            str += <span class="number">2</span>;</span><br><span class="line">            x += size; <span class="comment">//下一个汉字偏移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中实现了三个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_hz_mat()</span><br><span class="line">show_font()</span><br><span class="line">show_str()</span><br></pre></td></tr></table></figure></p><p>这三个函数都是移植正点原子的，后两个基本没有变化，你只需注意get_hz_mat()，因为它涉及到了flash的读写，而我们这里不再是裸机的读写方式，而是使用FAL软件包提供的API，尤其注意读写的位置，FAL软件包读的是分区相对位置！<br><br>有了上面这三个函数，初始化LCD完成后，你就可以使用show_str( )显示中文啦，例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_str(<span class="number">120</span>, <span class="number">220</span>, <span class="number">200</span>, <span class="number">16</span>, (<span class="keyword">rt_uint8_t</span> *)<span class="string">"霹雳大乌龙"</span>, <span class="number">16</span>);</span><br></pre></td></tr></table></figure></p><p>需要注意的是，你的源文件编码不能使用utf-8，否则将会显示错误的编码，这里提供一种解决方案：<br>使用notepad++，按如下设置：</p><p>好了，现在LCD已经可以显示中文了，但是你以为事情到这就结束了吗，no！！！一个致命的问题来了，这也是我前面说的百度语音埋下的坑。前面我提到，源文件不能使用utf-8编码，是针对源文件中的中文来说的，中文编码若是utf-8，那么你的LCD显示将会是错误的编码，用我上面提供的解决方案可以避免这个问题，但是！相信有人已经猜到了，我们要显示语音识别结果，它可不是直接写在源文件里的，而是我们接收百度语音返回的数据后，解析出来的，而它恰恰就是utf-8编码，你说悲不悲剧，这时上面说的解决方案可不管用了，那么怎么解决？我们下回分解。（不是卖关子，而是写在一起篇幅就太长了）</p><p>本次就分享到这吧~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本次我们还是先不实现录音功能，因为音频编解码这一块是比较有难度的，再加上RT-Thread的Audio设备也比较复杂，难以理解，我暂时没考虑
      
    
    </summary>
    
      <category term="语音识别" scheme="https://lxzzzzzxl.github.io/categories/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
      <category term="百度语音" scheme="https://lxzzzzzxl.github.io/tags/%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3/"/>
    
      <category term="RT-Thread" scheme="https://lxzzzzzxl.github.io/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现基于RT-Thread的百度语音识别（二）</title>
    <link href="https://lxzzzzzxl.github.io/2019/10/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ERT-Thread%E7%9A%84%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://lxzzzzzxl.github.io/2019/10/03/手把手教你实现基于RT-Thread的百度语音识别（二）/</id>
    <published>2019-10-03T10:12:19.000Z</published>
    <updated>2019-10-11T06:11:05.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在本次实践开始之前，你必须确保你已经做了以下两件事：</p><ol><li>注册百度开发者账号，并创建了一个语音识别应用，而且成功获取了Access Token（工程里将会用到）；</li><li>建立一个基于你自己的STM32平台的RT-Thread工程，它必须具备Finsh控制台，文件系统，网络功能（不明白的参见RT-Thread文档中心，网络功能推荐使用AT组件+ESP8266，因为这是最简单快捷的方法）。</li></ol><p>如果上面说的准备事项没有问题，那么请继续往下看：<br><br>这次我们将先跳过录音功能，而使用事先准备好的音频文件进行语音识别并控制板载RGB灯（上一篇的5，6点），所以你还需要准备一些音频文件，比如“红灯开”，“蓝灯关”。。。我是用手机录的音频，然后使用ffmpeg工具将音频转为百度语音官方认为最适合的16k采样率pcm文件，最后将这些音频文件放进sd卡中，我们的文件系统也是挂载在sd卡上的。</p><h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h2><p>本次工程会用到RT-Thread的两个软件包：webclient和CJSON软件包，你需要使用ENV工具将这两个软件包添加进工程里。<br><br>好了，开始写代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bd_speech_rcg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; //网络功能需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;webclient.h&gt;  //webclient软件包头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dfs_posix.h&gt;  //文件系统需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cJSON.h&gt;      //CJSON软件包头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用外设需要的头文件 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;board.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取RGB灯对应的引脚编号 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN_LED_RGET_PIN(E,  7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN_LED_GGET_PIN(E,  8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIN_LED_BGET_PIN(E,  9)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RES_BUFFER_SIZE     4096        <span class="comment">//数据接收数组大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_BUFFER_SIZE      2048    <span class="comment">//最大支持的头部长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* URL */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST_FILE_URL  <span class="meta-string">"http://vop.baidu.com/server_api?dev_pid=1536&amp;cuid=lxzzzzzxl&amp;token=25.9119f50a60602866be9288f1f14a1059.315360000.1884092937.282335-15525116"</span></span></span><br><span class="line"><span class="comment">/* 头部数据（必需） */</span></span><br><span class="line"><span class="keyword">char</span> *form_data = <span class="string">"audio/pcm;rate=16000"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 预定义的命令 */</span></span><br><span class="line"><span class="keyword">char</span> *cmd1 = <span class="string">"打开红灯"</span>;</span><br><span class="line"><span class="keyword">char</span> *cmd2 = <span class="string">"关闭红灯"</span>;</span><br><span class="line"><span class="keyword">char</span> *cmd3 = <span class="string">"打开蓝灯"</span>;</span><br><span class="line"><span class="keyword">char</span> *cmd4 = <span class="string">"关闭蓝灯"</span>;</span><br><span class="line"><span class="keyword">char</span> *cmd5 = <span class="string">"打开绿灯"</span>;</span><br><span class="line"><span class="keyword">char</span> *cmd6 = <span class="string">"关闭绿灯"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">函数名称 ： bd</span></span><br><span class="line"><span class="comment">功    能 ： 将音频文件发送到百度语音服务器，并接收响应数据</span></span><br><span class="line"><span class="comment">参    数 ： 音频文件名（注意在文件系统中的位置，默认根目录）</span></span><br><span class="line"><span class="comment">返 回 值 ： void</span></span><br><span class="line"><span class="comment">作    者 ： rtthread；霹雳大乌龙</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *filename = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = RT_NULL;</span><br><span class="line"><span class="keyword">int</span> content_length = <span class="number">-1</span>, bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> content_pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断命令是否合法 */</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">rt_kprintf(<span class="string">"bd &lt;filename&gt;\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取音频文件名 */</span></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以只读方式打开音频文件 */</span></span><br><span class="line"><span class="keyword">int</span> fd = open(filename, O_RDONLY, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">rt_kprintf(<span class="string">"open %d fail!\r\n"</span>, filename);</span><br><span class="line"><span class="keyword">goto</span> __exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取音频文件大小 */</span></span><br><span class="line"><span class="keyword">size_t</span> length = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建响应数据接收数据 */</span></span><br><span class="line">buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) web_malloc(RES_BUFFER_SIZE);</span><br><span class="line"><span class="keyword">if</span>(buffer == RT_NULL)</span><br><span class="line">&#123;</span><br><span class="line">rt_kprintf(<span class="string">"no memory for receive response buffer.\n"</span>);</span><br><span class="line">        ret = -RT_ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> __exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建会话 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">webclient_session</span> *<span class="title">session</span> = <span class="title">webclient_session_create</span>(<span class="title">HEADER_BUFFER_SIZE</span>);</span></span><br><span class="line"><span class="keyword">if</span>(session == RT_NULL)</span><br><span class="line">&#123;</span><br><span class="line">ret = -RT_ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> __exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拼接头部数据 */</span></span><br><span class="line">webclient_header_fields_add(session, <span class="string">"Content-Length: %d\r\n"</span>, length);</span><br><span class="line">webclient_header_fields_add(session, <span class="string">"Content-Type: %s\r\n"</span>, form_data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送POST请求 */</span></span><br><span class="line"><span class="keyword">int</span> rc = webclient_post(session, POST_FILE_URL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(rc &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">rt_kprintf(<span class="string">"webclient post data error!\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __exit;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">"webclient connected and send header msg!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">"rc code: %d!\n"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">rt_memset(buffer, <span class="number">0</span>, RES_BUFFER_SIZE);</span><br><span class="line">length = read(fd, buffer, RES_BUFFER_SIZE);</span><br><span class="line"><span class="keyword">if</span>(length &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = webclient_write(session, buffer, length);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">rt_kprintf(<span class="string">"webclient write error!\r\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">rt_thread_mdelay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">rt_kprintf(<span class="string">"Upload voice data successfully\r\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(webclient_handle_response(session) != <span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">"get handle resposne error!"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取接收的响应数据长度 */</span></span><br><span class="line">content_length = webclient_content_length_get(session);</span><br><span class="line">rt_thread_delay(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">bytes_read = webclient_read(session, buffer, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; bytes_read; index++)</span><br><span class="line">&#123;</span><br><span class="line">rt_kprintf(<span class="string">"%c"</span>, buffer[index]);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        content_pos += bytes_read;</span><br><span class="line">&#125;<span class="keyword">while</span>(content_pos &lt; content_length);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解析json数据 */</span></span><br><span class="line">bd_data_parse(buffer);</span><br><span class="line"></span><br><span class="line">__exit:</span><br><span class="line"><span class="keyword">if</span>(fd &gt;= <span class="number">0</span>)</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">if</span>(session != <span class="literal">NULL</span>)</span><br><span class="line">webclient_close(session);</span><br><span class="line"><span class="keyword">if</span>(buffer != <span class="literal">NULL</span>)</span><br><span class="line">web_free(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导出为命令形式 */</span></span><br><span class="line">MSH_CMD_EXPORT(bd, webclient post file);</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">函数名称 ： bd_data_parse</span></span><br><span class="line"><span class="comment">功    能 ： 解析json数据，并作出响应动作</span></span><br><span class="line"><span class="comment">参    数 ： data ------ 百度语音服务返回的数据（json格式）</span></span><br><span class="line"><span class="comment">返 回 值 ： void</span></span><br><span class="line"><span class="comment">作    者 ： RT-Thread；霹雳大乌龙</span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bd_data_parse</span><span class="params">(<span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON *root = RT_NULL, *object = RT_NULL, *item =RT_NULL;</span><br><span class="line"></span><br><span class="line">    root = cJSON_Parse((<span class="keyword">const</span> <span class="keyword">char</span> *)data);</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">"No memory for cJSON root!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    object = cJSON_GetObjectItem(root, <span class="string">"result"</span>);</span><br><span class="line"></span><br><span class="line">item = object-&gt;child;</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">"\nresult:%s \r\n"</span>, item-&gt;valuestring);</span><br><span class="line"></span><br><span class="line">rt_pin_mode(PIN_LED_R, PIN_MODE_OUTPUT);</span><br><span class="line">rt_pin_mode(PIN_LED_G, PIN_MODE_OUTPUT);</span><br><span class="line">rt_pin_mode(PIN_LED_B, PIN_MODE_OUTPUT);</span><br><span class="line">rt_pin_write(PIN_LED_R,<span class="number">1</span>);</span><br><span class="line">rt_pin_write(PIN_LED_G,<span class="number">1</span>);</span><br><span class="line">rt_pin_write(PIN_LED_B,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>((<span class="keyword">char</span>*)data, cmd1) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 打开红灯 */</span></span><br><span class="line">rt_pin_write(PIN_LED_R,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>((<span class="keyword">char</span>*)data, cmd2) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 关闭红灯 */</span></span><br><span class="line">rt_pin_write(PIN_LED_R,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>((<span class="keyword">char</span>*)data, cmd3) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 打开蓝灯 */</span></span><br><span class="line">rt_pin_write(PIN_LED_B,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>((<span class="keyword">char</span>*)data, cmd4) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 关闭蓝灯 */</span></span><br><span class="line">rt_pin_write(PIN_LED_B,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>((<span class="keyword">char</span>*)data, cmd5) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 打开绿灯 */</span></span><br><span class="line">rt_pin_write(PIN_LED_G,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>((<span class="keyword">char</span>*)data, cmd6) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 关闭绿灯 */</span></span><br><span class="line">rt_pin_write(PIN_LED_G,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root != RT_NULL)</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需以上的代码，你就可以实现百度语音识别以及控制相应外设了。下面看看实际效果：<br><br>我使用的潘多拉开发板板载了stlink（且其为我们提供了一个虚拟串口），用usb数据线将开发板和电脑连接起来，将代码烧写进开发板后，我们利用这个虚拟串口，使用Xshell一类的终端软件，就可以看到如下的开机画面：<br><img src="https://ftp.bmp.ovh/imgs/2019/10/bdfc1e5c5e29b5d8.png" alt><br>这便是RT-Thread提供的Finsh控制台组件，使用这个组件，我们可以方便地观察程序的运行状态，以命令行的形式调试运行程序，从图中我们可以看到，我们需要的文件系统和网络功能都已经初始化成功。</p><p>使用ls命令看看：<br><img src="https://ftp.bmp.ovh/imgs/2019/10/aa9765bde9fb096e.png" alt><br>欸~，这便是我事先准备好的音频文件。</p><p>在上面的代码中，我们可以看到有这样一句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSH_CMD_EXPORT(bd, webclient post file);</span><br></pre></td></tr></table></figure></p><p>通过这行代码，我们就可以在Finsh控制台里使用bd这个命令，这个命令就是将音频文件发送到百度语音服务器，试试看：<br><img src="https://ftp.bmp.ovh/imgs/2019/10/3b3f17044d530b3b.png" alt></p><p>看，我使用bd命令将greenon.pcm发送到百度语音服务器，正确识别出结果：“打开绿灯”；于此同时，rgb灯也亮起了绿色</p><p><img src="https://ftp.bmp.ovh/imgs/2019/10/3298f9616fd1a0f9.jpg" alt></p><p>尝试其他音频文件，效果完美！！！</p><p>好了，本次分享也就到这了，觉得不错的帮忙转发点个在看哦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;在本次实践开始之前，你必须确保你已经做了以下两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册百度开发者账号，并创建了一个语音识别应用
      
    
    </summary>
    
      <category term="语音识别" scheme="https://lxzzzzzxl.github.io/categories/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
      <category term="百度语音" scheme="https://lxzzzzzxl.github.io/tags/%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3/"/>
    
      <category term="RT-Thread" scheme="https://lxzzzzzxl.github.io/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread学习笔记 —— 信号量</title>
    <link href="https://lxzzzzzxl.github.io/2019/05/02/RT-Thread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E2%80%94%E2%80%94%20%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>https://lxzzzzzxl.github.io/2019/05/02/RT-Thread学习笔记 —— 信号量/</id>
    <published>2019-05-02T06:12:00.000Z</published>
    <updated>2019-05-02T06:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号量控制块"><a href="#信号量控制块" class="headerlink" title="信号量控制块"></a>信号量控制块</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span></span><br><span class="line">    <span class="keyword">rt_unit16_t</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_semaphore</span>* <span class="title">rt_sem_t</span>;</span></span><br></pre></td></tr></table></figure><a id="more"></a>  <h2 id="信号量的管理方式"><a href="#信号量的管理方式" class="headerlink" title="信号量的管理方式"></a>信号量的管理方式</h2><p>信号量的相关接口如下：<br><a href="#head1"><code>rt_sem_create 创建信号量</code></a><br><a href="#head2"><code>rt_sem_delete 删除信号量</code></a><br><a href="#head3"><code>rt_sem_init 初始化信号量</code></a><br><a href="#head4"><code>rt_sem_detach 脱离信号量</code></a><br><a href="#head5"><code>rt_sem_take/trytake 获取信号量</code></a><br><a href="#head6"><code>rt_sem_release 释放信号量</code></a>  </p><p><a id="head1"></a></p><h2 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_sem_t</span> rt_sem_create(<span class="keyword">const</span> <span class="keyword">char</span> *name,           <span class="comment">//信号量名称</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> vaule,         <span class="comment">//信号量初始值</span></span><br><span class="line">                        <span class="keyword">rt_uint8_t</span> flag);          <span class="comment">//信号量标志</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回信号量控制块指针，失败返回RT_NULL</span><br><span class="line">-&gt;  flag可取值如下：</span><br><span class="line">    RT_IPC_FLAG_FIFO(先进先出)</span><br><span class="line">    RT_IPC_FLAG_PRIO(优先级等待)</span><br></pre></td></tr></table></figure><p><a id="head2"></a></p><h2 id="删除信号量"><a href="#删除信号量" class="headerlink" title="删除信号量"></a>删除信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_delete(<span class="keyword">rt_sem_t</span> sem);               <span class="comment">//信号量对象</span></span><br><span class="line"></span><br><span class="line">-&gt; 成功返回RT_EOK</span><br></pre></td></tr></table></figure><p><a id="head3"></a></p><h2 id="初始化信号量"><a href="#初始化信号量" class="headerlink" title="初始化信号量"></a>初始化信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_init(<span class="keyword">rt_sem_t</span> sem,              <span class="comment">//信号量对象句柄</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *name,       <span class="comment">//信号量名称</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> vaule,      <span class="comment">//信号量初始值</span></span><br><span class="line">                        <span class="keyword">rt_uint8_t</span> flag);       <span class="comment">//信号量标志</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK</span><br></pre></td></tr></table></figure><p><a id="head4"></a></p><h2 id="脱离信号量"><a href="#脱离信号量" class="headerlink" title="脱离信号量"></a>脱离信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_detach(<span class="keyword">rt_sem_t</span> sem);</span><br></pre></td></tr></table></figure><p><a id="head5"></a></p><h2 id="获取信号量"><a href="#获取信号量" class="headerlink" title="获取信号量"></a>获取信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_take(<span class="keyword">rt_sem_t</span> sem,              <span class="comment">//信号量对象句柄</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> time);      <span class="comment">//等待时间</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,超时返回-RT_ETIMEOUT,其他错误返回-RT_ERROR</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_sem_trytake(<span class="keyword">rt_sem_t</span> sem);          <span class="comment">//无等待获取信号量</span></span><br></pre></td></tr></table></figure><p><a id="head6"></a></p><h2 id="释放信号量"><a href="#释放信号量" class="headerlink" title="释放信号量"></a>释放信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_sem_release(<span class="keyword">rt_sem_t</span> sem);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信号量控制块&quot;&gt;&lt;a href=&quot;#信号量控制块&quot; class=&quot;headerlink&quot; title=&quot;信号量控制块&quot;&gt;&lt;/a&gt;信号量控制块&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rt_semaphore&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rt_ipc_object&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;parent&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;rt_unit16_t&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rt_semaphore&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;rt_sem_t&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="RT-Thread" scheme="https://lxzzzzzxl.github.io/categories/RT-Thread/"/>
    
    
      <category term="RT-thread" scheme="https://lxzzzzzxl.github.io/tags/RT-thread/"/>
    
      <category term="线程同步" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
      <category term="信号量" scheme="https://lxzzzzzxl.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread学习笔记 —— UART串口</title>
    <link href="https://lxzzzzzxl.github.io/2019/04/28/RT-Thread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E2%80%94%E2%80%94%20UART%E4%B8%B2%E5%8F%A3/"/>
    <id>https://lxzzzzzxl.github.io/2019/04/28/RT-Thread学习笔记 —— UART串口/</id>
    <published>2019-04-28T08:43:00.000Z</published>
    <updated>2019-04-28T10:00:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问串口设备"><a href="#访问串口设备" class="headerlink" title="访问串口设备"></a>访问串口设备</h2><p>应用程序通过 RT-Thread提供的 I/O 设备管理接口来访问串口硬件，相关接口如下所示：  </p><a id="more"></a>  <p><a href="#head1"><code>rt_device_find()    查找设备</code></a><br><a href="#head2"><code>rt_device_open()    打开设备</code></a><br><a href="#head3"><code>rt_device_read()    读取数据</code></a><br><a href="#head4"><code>rt_device_write()    写入数据</code></a><br><a href="#head5"><code>rt_device_control()    控制设备</code></a><br><a href="#head6"><code>rt_device_set_rx_indicate()    设置接收回调函数</code></a><br><a href="#head7"><code>rt_device_set_tx_complete()    设置发送完成回调函数</code></a><br><a href="#head8"><code>rt_device_close()    关闭设备</code></a></p><p><a id="head1"></a></p><h2 id="查找串口设备"><a href="#查找串口设备" class="headerlink" title="查找串口设备"></a>查找串口设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_device_t</span> rt_device_find(</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">char</span>* name);              <span class="comment">//设备名称</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回设备句柄，失败返回RT_NULL</span><br></pre></td></tr></table></figure><p><a id="head2"></a></p><h2 id="打开设备"><a href="#打开设备" class="headerlink" title="打开设备"></a>打开设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_open(<span class="keyword">rt_device_t</span> dev,                    <span class="comment">//设备句柄</span></span><br><span class="line">                        <span class="keyword">rt_uint16_t</span> oflags);                <span class="comment">//设备访问模式标志</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_EBUSY(或其他错误代码)</span><br><span class="line">-&gt;  oflags支持以下参数：</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_CLOSE                   <span class="comment">//设备已经关闭</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_RDONLY                  <span class="comment">//以只读方式打开设备</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_WRONLY                  <span class="comment">//以只写方式打开设备</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_RDWR                    <span class="comment">//以读写方式打开设备</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_OFLAG_OPEN                    <span class="comment">//设备已经打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_STREAM                   <span class="comment">//设备以流模式打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_INT_RX                   <span class="comment">//设备以中断接收模式打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_DMA_RX                   <span class="comment">//设备以DMA接收模式打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_INT_TX                   <span class="comment">//设备以中断发送模式打开</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RT_DEVICE_FLAG_DMA_TX                   <span class="comment">//设备以DMA发送模式打开</span></span></span><br></pre></td></tr></table></figure><p><a id="head3"></a></p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_size_t</span> rt_device_read(<span class="keyword">rt_device_t</span> dev,           <span class="comment">//设备句柄</span></span><br><span class="line">                         <span class="keyword">rt_off_t</span> pos,              <span class="comment">//读取数据偏移量</span></span><br><span class="line">                         <span class="keyword">void</span>* buffer,              <span class="comment">//内存缓冲区指针</span></span><br><span class="line">                         <span class="keyword">rt_size_t</span> size);           <span class="comment">//读取数据的大小</span></span><br><span class="line"></span><br><span class="line">-&gt;  返回读到数据的实际大小</span><br></pre></td></tr></table></figure><p><a id="head4"></a></p><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_size_t</span> rt_device_write(<span class="keyword">rt_device_t</span> dev,          <span class="comment">//设备句柄</span></span><br><span class="line">                          <span class="keyword">rt_off_t</span> pos,             <span class="comment">//写入数据偏移量</span></span><br><span class="line">                          <span class="keyword">const</span> <span class="keyword">void</span>* buffer,       <span class="comment">//内存缓冲区</span></span><br><span class="line">                          <span class="keyword">rt_size_t</span> size);          <span class="comment">//写入数据的大小</span></span><br><span class="line"></span><br><span class="line">-&gt;  返回写入数据的实际大小</span><br></pre></td></tr></table></figure><p><a id="head5"></a></p><h2 id="控制设备"><a href="#控制设备" class="headerlink" title="控制设备"></a>控制设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_control(<span class="keyword">rt_device_t</span> dev,         <span class="comment">//设备句柄</span></span><br><span class="line">                            <span class="keyword">rt_uint8_t</span> cmd,         <span class="comment">//控制命令</span></span><br><span class="line">                            <span class="keyword">void</span>* arg);             <span class="comment">//控制参数</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ENOSYS(或其他错误代码)</span><br></pre></td></tr></table></figure><p><a id="head6"></a></p><h2 id="设置接收回调函数"><a href="#设置接收回调函数" class="headerlink" title="设置接收回调函数"></a>设置接收回调函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_set_rx_indicate(<span class="keyword">rt_device_t</span> dev,             <span class="comment">//设备句柄</span></span><br><span class="line">    <span class="keyword">rt_err_t</span> (*rx_ind)(<span class="keyword">rt_device_t</span> dev, <span class="keyword">rt_size_t</span> size));       <span class="comment">//回调函数指针</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK</span><br></pre></td></tr></table></figure><p><a id="head7"></a></p><h2 id="设置发送完成回调函数"><a href="#设置发送完成回调函数" class="headerlink" title="设置发送完成回调函数"></a>设置发送完成回调函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_set_tx_complete(<span class="keyword">rt_device_t</span> dev,             <span class="comment">//设备句柄</span></span><br><span class="line">    <span class="keyword">rt_err_t</span> (*tx_done)(<span class="keyword">rt_device_t</span> dev, <span class="keyword">void</span> *buffer));        <span class="comment">//回调函数指针</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK</span><br></pre></td></tr></table></figure><p><a id="head8"></a></p><h2 id="关闭设备"><a href="#关闭设备" class="headerlink" title="关闭设备"></a>关闭设备</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_device_close(<span class="keyword">rt_device_t</span> dev);              <span class="comment">//设备句柄</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR(或其他错误码)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;访问串口设备&quot;&gt;&lt;a href=&quot;#访问串口设备&quot; class=&quot;headerlink&quot; title=&quot;访问串口设备&quot;&gt;&lt;/a&gt;访问串口设备&lt;/h2&gt;&lt;p&gt;应用程序通过 RT-Thread提供的 I/O 设备管理接口来访问串口硬件，相关接口如下所示：  &lt;/p&gt;
    
    </summary>
    
      <category term="RT-Thread" scheme="https://lxzzzzzxl.github.io/categories/RT-Thread/"/>
    
    
      <category term="RT-thread" scheme="https://lxzzzzzxl.github.io/tags/RT-thread/"/>
    
      <category term="UART串口" scheme="https://lxzzzzzxl.github.io/tags/UART%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread学习笔记 —— 线程管理</title>
    <link href="https://lxzzzzzxl.github.io/2019/04/28/RT-Thread%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%20%E2%80%94%E2%80%94%20%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://lxzzzzzxl.github.io/2019/04/28/RT-Thread学习笔记  —— 线程管理/</id>
    <published>2019-04-28T04:19:00.000Z</published>
    <updated>2019-04-28T04:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和删除线程（动态线程）"><a href="#创建和删除线程（动态线程）" class="headerlink" title="创建和删除线程（动态线程）"></a>创建和删除线程（动态线程）</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_thread_t</span> rt_thread_create(<span class="keyword">const</span> <span class="keyword">char</span>* name,                  <span class="comment">//线程名称</span></span><br><span class="line">                            <span class="keyword">void</span> (*entry) (<span class="keyword">void</span>* parameter),    <span class="comment">//线程入口函数</span></span><br><span class="line">                            <span class="keyword">void</span>* parameter,                    <span class="comment">//线程入口函数参数</span></span><br><span class="line">                            <span class="keyword">rt_uint32_t</span> stack_size,             <span class="comment">//线程栈大小，单位是字节</span></span><br><span class="line">                            <span class="keyword">rt_uint8_t</span> priority,                <span class="comment">//线程优先级</span></span><br><span class="line">                            <span class="keyword">rt_uint32_t</span> tick);                  <span class="comment">//线程时间片大小</span></span><br><span class="line"></span><br><span class="line">-&gt;  线程创建成功返回线程句柄，失败返回RT_NULL</span><br></pre></td></tr></table></figure><h3 id="删除线程"><a href="#删除线程" class="headerlink" title="删除线程"></a>删除线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_delete(</span><br><span class="line">                            <span class="keyword">rt_thread_t</span> thread                  <span class="comment">//要删除的线程句柄</span></span><br><span class="line">                            );</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><a id="more"></a>  <h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_PRIORITY         25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_STACK_SIZE512    512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_TIMESLICE        5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread1_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">"thread1 count: %d\n"</span>, count ++);</span><br><span class="line">        rt_thread_mdelay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thread_sample</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tid1 = rt_thread_create(<span class="string">"thread1"</span>,</span><br><span class="line">                            thread1_entry,</span><br><span class="line">                            RT_NULL,</span><br><span class="line">                            THREAD_STACK_SIZE,</span><br><span class="line">                            THREAD_PRIORITY,</span><br><span class="line">                            THREAD_TIMESLICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL)</span><br><span class="line">        rt_thread_startup(tid1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化和脱离线程（静态线程）"><a href="#初始化和脱离线程（静态线程）" class="headerlink" title="初始化和脱离线程（静态线程）"></a>初始化和脱离线程（静态线程）</h2><h3 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_init(struct rt_thread* thread,               <span class="comment">//线程句柄</span></span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">char</span>* name,                       <span class="comment">//线程名称</span></span><br><span class="line">                        <span class="keyword">void</span> (*entry) (<span class="keyword">void</span>* parameter),        <span class="comment">//线程入口函数</span></span><br><span class="line">                        <span class="keyword">void</span>* parameter,                        <span class="comment">//线程入口函数参数</span></span><br><span class="line">                        <span class="keyword">void</span>* stack_start,                      <span class="comment">//线程栈起始地址</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> stack_size,                 <span class="comment">//线程栈大小</span></span><br><span class="line">                        <span class="keyword">rt_uint8_t</span> priority,                    <span class="comment">//线程优先级</span></span><br><span class="line">                        <span class="keyword">rt_uint32_t</span> tick);                      <span class="comment">//线程时间片大小</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h3 id="脱离线程"><a href="#脱离线程" class="headerlink" title="脱离线程"></a>脱离线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_detach(</span><br><span class="line">                            <span class="keyword">rt_thread_t</span> thread                  <span class="comment">//要脱离的线程句柄</span></span><br><span class="line">                            );</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_PRIORITY         25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_STACK_SIZE512    512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_TIMESLICE        5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> <span class="title">thread2</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> thread2_stack[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread2_entry</span><span class="params">(<span class="keyword">void</span> *parameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rt_uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_kprintf(<span class="string">"thread1 count: %d\n"</span>, count ++);</span><br><span class="line">        rt_thread_mdelay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thread_sample</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt_thread_init(&amp;thread2,</span><br><span class="line">                    <span class="string">"thread2"</span>,</span><br><span class="line">                    thread2_entry,</span><br><span class="line">                    RT_NULL,</span><br><span class="line">                    &amp;thread2_stack[<span class="number">0</span>],</span><br><span class="line">                    <span class="keyword">sizeof</span>(thread2_stack),</span><br><span class="line">                    THREAD_PRIORITY,</span><br><span class="line">                    THREAD_TIMESLICE);</span><br><span class="line">    </span><br><span class="line">    rt_thread_startup(&amp;thread2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_startup(<span class="keyword">rt_thread_t</span> thread);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h2 id="获得当前线程"><a href="#获得当前线程" class="headerlink" title="获得当前线程"></a>获得当前线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_thread_t</span> rt_thread_self(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回当前运行的线程句柄，失败返回RT_NULL(调度器未启动)</span><br></pre></td></tr></table></figure><h2 id="使线程让出处理器资源"><a href="#使线程让出处理器资源" class="headerlink" title="使线程让出处理器资源"></a>使线程让出处理器资源</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_yield(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">rt_schedule()</span><br></pre></td></tr></table></figure><h2 id="使线程睡眠"><a href="#使线程睡眠" class="headerlink" title="使线程睡眠"></a>使线程睡眠</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_sleep(<span class="keyword">rt_tick_t</span> tick);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_delay(<span class="keyword">rt_tick_t</span> tick);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_mdelay(<span class="keyword">rt_uint32_t</span> ms);</span><br></pre></td></tr></table></figure><h2 id="挂起和恢复线程"><a href="#挂起和恢复线程" class="headerlink" title="挂起和恢复线程"></a>挂起和恢复线程</h2><h3 id="挂起线程"><a href="#挂起线程" class="headerlink" title="挂起线程"></a>挂起线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_suspend(<span class="keyword">rt_thread_t</span> thread);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h3 id="恢复线程"><a href="#恢复线程" class="headerlink" title="恢复线程"></a>恢复线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_resume(<span class="keyword">rt_thread_t</span> thread);</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br></pre></td></tr></table></figure><h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_control(<span class="keyword">rt_thread_t</span> thread,              <span class="comment">//线程句柄</span></span><br><span class="line">                            <span class="keyword">rt_uint8_t</span> cmd,                 <span class="comment">//控制命令</span></span><br><span class="line">                             <span class="keyword">void</span>* arg);                    <span class="comment">//控制参数</span></span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_ERROR</span><br><span class="line"></span><br><span class="line">支持如下cmd命令：</span><br><span class="line">                RT_THREAD_CTRL_CHANGE_PRIORITY              <span class="comment">//动态更改线程优先级</span></span><br><span class="line">                RT_THREAD_CTRL_STARTUP                      <span class="comment">//开始运行一个线程</span></span><br><span class="line">                RT_THREAD_CTRL_CLOSE                        <span class="comment">//关闭一个线程</span></span><br></pre></td></tr></table></figure><h2 id="设置和删除空闲钩子"><a href="#设置和删除空闲钩子" class="headerlink" title="设置和删除空闲钩子"></a>设置和删除空闲钩子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rt_err_t</span> rt_thread_idle_sethook(<span class="keyword">void</span> (*hook)(<span class="keyword">void</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">rt_err_t</span> rt_thread_idle_delhook(<span class="keyword">void</span> (*hook)(<span class="keyword">void</span>));</span><br><span class="line"></span><br><span class="line">-&gt;  成功返回RT_EOK,失败返回-RT_EFULL</span><br><span class="line">-&gt;  hook:设置的钩子函数</span><br></pre></td></tr></table></figure><h2 id="设置调度器钩子"><a href="#设置调度器钩子" class="headerlink" title="设置调度器钩子"></a>设置调度器钩子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_scheduler_sethook</span><span class="params">(<span class="keyword">void</span> (*hook)(struct rt_thread* from, struct rt_thread* to))</span></span>;</span><br><span class="line"></span><br><span class="line">-&gt;  钩子函数声明如下：</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">(struct rt_thread* from, struct rt_thread* to)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建和删除线程（动态线程）&quot;&gt;&lt;a href=&quot;#创建和删除线程（动态线程）&quot; class=&quot;headerlink&quot; title=&quot;创建和删除线程（动态线程）&quot;&gt;&lt;/a&gt;创建和删除线程（动态线程）&lt;/h2&gt;&lt;h3 id=&quot;创建线程&quot;&gt;&lt;a href=&quot;#创建线程&quot; class=&quot;headerlink&quot; title=&quot;创建线程&quot;&gt;&lt;/a&gt;创建线程&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;rt_thread_t&lt;/span&gt; rt_thread_create(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* name,                  &lt;span class=&quot;comment&quot;&gt;//线程名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*entry) (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* parameter),    &lt;span class=&quot;comment&quot;&gt;//线程入口函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* parameter,                    &lt;span class=&quot;comment&quot;&gt;//线程入口函数参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;rt_uint32_t&lt;/span&gt; stack_size,             &lt;span class=&quot;comment&quot;&gt;//线程栈大小，单位是字节&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;rt_uint8_t&lt;/span&gt; priority,                &lt;span class=&quot;comment&quot;&gt;//线程优先级&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;rt_uint32_t&lt;/span&gt; tick);                  &lt;span class=&quot;comment&quot;&gt;//线程时间片大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt;  线程创建成功返回线程句柄，失败返回RT_NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;删除线程&quot;&gt;&lt;a href=&quot;#删除线程&quot; class=&quot;headerlink&quot; title=&quot;删除线程&quot;&gt;&lt;/a&gt;删除线程&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;rt_err_t&lt;/span&gt; rt_thread_delete(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;rt_thread_t&lt;/span&gt; thread                  &lt;span class=&quot;comment&quot;&gt;//要删除的线程句柄&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt;  成功返回RT_EOK,失败返回-RT_ERROR&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="RT-Thread" scheme="https://lxzzzzzxl.github.io/categories/RT-Thread/"/>
    
    
      <category term="RT-thread" scheme="https://lxzzzzzxl.github.io/tags/RT-thread/"/>
    
      <category term="线程管理" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(C语言) —— 队列</title>
    <link href="https://lxzzzzzxl.github.io/2019/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(C%E8%AF%AD%E8%A8%80)%20%E2%80%94%E2%80%94%20%E9%98%9F%E5%88%97/"/>
    <id>https://lxzzzzzxl.github.io/2019/04/12/数据结构(C语言) —— 队列/</id>
    <published>2019-04-12T12:27:19.000Z</published>
    <updated>2019-04-14T02:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h1><p>队列也是一种特殊的线性表，队列的数据元素及数据元素间的逻辑关系和线性表完全相同；其差别在于，线性表允许在任意位置插入和删除数据元素，而队列只允许在其一端进行插入操作，在另一端进行删除操作；进行插入操作的一端称为队尾，允许删除操作的一端称为队头。队列是一种先进先出的线性表。</p><a id="more"></a>  <h2 id="顺序循环队列的表示和实现"><a href="#顺序循环队列的表示和实现" class="headerlink" title="顺序循环队列的表示和实现"></a>顺序循环队列的表示和实现</h2><h3 id="顺序循环队列的结构体定义如下："><a href="#顺序循环队列的结构体定义如下：" class="headerlink" title="顺序循环队列的结构体定义如下："></a>顺序循环队列的结构体定义如下：</h3><pre><code>typedef struct{    DataType queue[MaxQueueSize];    int rear;                //队尾指针    int front;               //队头指针    int count;             //计数器}SeqCQueue;</code></pre><h3 id="顺序循环队列的算法实现如下："><a href="#顺序循环队列的算法实现如下：" class="headerlink" title="顺序循环队列的算法实现如下："></a>顺序循环队列的算法实现如下：</h3><p>1.初始化</p><pre><code>void QueueInitiate(SeqCQueue *Q){    Q-&gt;rear = 0;    Q-&gt;front = 0;    Q-&gt;count = 0;}</code></pre><p>2.判断非空否</p><pre><code>int QueueNotEmpty(SeqCQueue Q){    if(Q.count != 0) return 1;    else return 0;}</code></pre><p>3.入队列</p><pre><code>QueueAppend(SeqCQueue *Q, DataType x){    if(Q-&gt;count &gt; 0 &amp;&amp; Q-&gt;rear == Q-&gt;front)    {        printf(&quot;队列已满无法插入！&quot;);        return 0;    }    else    {        Q-&gt;queue[Q-&gt;rear] = x;        Q-&gt;rear = (Q-&gt;rear + 1) % MaxQueueSize;        Q-&gt;count ++;        return 1;    }}</code></pre><p>4.出队列</p><pre><code>QueueDelete(SeqCQueue *Q, DataType *d){    if(Q-&gt;count == 0)    {        printf(&quot;队列已空！&quot;);        return 0;    }    else    {        *d = Q-&gt;queue[Q-&gt;front];        Q-&gt;front = (Q-&gt;front + 1) % MaxQueueSize;        Q-&gt;count --;        return 1;    }}</code></pre><p>5.取队头数据元素</p><pre><code>int QueueGet(SeqCQueue Q, DataType *d){    if(Q.count == 0)    {        printf(&quot;队列已空！&quot;);        return 0；    }    else    {        *d = Q.queue[Q.front];        return 1;    }}</code></pre><h2 id="链式队列的表示和实现"><a href="#链式队列的表示和实现" class="headerlink" title="链式队列的表示和实现"></a>链式队列的表示和实现</h2><h3 id="链式队列的存储结构"><a href="#链式队列的存储结构" class="headerlink" title="链式队列的存储结构"></a>链式队列的存储结构</h3><p> 链式队列中结点的结构体定义如下：</p><pre><code>typedef struct qnode{    DataType data;    struct qnode *next;}LQNode;</code></pre><p> 定义链式队列的队头指针front和队尾指针rear的结构体如下：</p><pre><code>typedef struct{    LQNode *front;    LQNode *rear;}LQueue;                   //可看做初始队列</code></pre><h3 id="链式队列操作的实现"><a href="#链式队列操作的实现" class="headerlink" title="链式队列操作的实现"></a>链式队列操作的实现</h3><p>1.初始化  </p><pre><code>void QueueInitiate(LQueue *Q){    Q-&gt;rear = NULL;    Q-&gt;front = NULL;}</code></pre><p>2.判断非空否  </p><pre><code>int QueueNotEmpty(LQueue Q){    if(Q.front == NULL) return 0;    else return 1;}</code></pre><p>3.入队列  </p><pre><code>void QueueAppend(LQueue *Q, DataType x){    LQNode *p;    p = (LQNode *)malloc(sizeof(LQNode));    p-&gt;data = x;    p-&gt;next = NULL;    if(Q-&gt;rear != NULL) Q-&gt;rear-&gt;next = p;  //队列原本非空时，队尾加新节点    Q-&gt;rear = p;                            //修改队尾指针    if(Q-&gt;front == NULL) Q-&gt;front = p;      //队列原本为空时，修改队头指针}</code></pre><p>4.出队列  </p><pre><code>int QueueDelete(LQueue *Q, DataType *d){    LQNode *p;    if(Q-&gt;front == NULL)    {        printf(&quot;队列已空！&quot;);        return 0;    }    else    {        *d = Q-&gt;front-&gt;data;        p = Q-&gt;front;        Q-&gt;front = Q-&gt;front-&gt;next;        if(Q-&gt;front == NULL) Q-&gt;rear = NULL;    //删除最后一个结点后，要置队尾指针为空        free(p);        return 1;    }}</code></pre><p>5.取队头数据元素  </p><pre><code>int QueueGet(LQueue Q, DataType *d){    if(Q.front == NULL)    {        printf(&quot;队列已空！&quot;);        return 0;    }    else    {        *d = Q.front-&gt;data;        return 1;    }}</code></pre><p>6.撤销动态申请空间  </p><pre><code>void Destory(LQueue Q){    LQNode *p, *p1;    p = Q.front;    while(p != NULL)    {        p1 = p;        p = p-&gt;next;        free(p1);    }}</code></pre><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列与一般队列的主要区别是：优先级队列的出队操作不是把队头元素出队列，而是把队列中优先级最高的数据元素出队列。</p><h3 id="顺序优先级队列的设计和实现"><a href="#顺序优先级队列的设计和实现" class="headerlink" title="顺序优先级队列的设计和实现"></a>顺序优先级队列的设计和实现</h3><p>优先级队列的数据元素的结构体定义如下：</p><pre><code>typedef struct{    int priority;           //优先级     ElemType elem;      //其他内容} DataType;</code></pre><p>优先级队列的结构体定义如下：</p><pre><code>typedef struct{    DataType queue[MaxQueueSize];    int size;} SeqPQueue;</code></pre><p>1.初始化</p><pre><code>void QueueInitiate(SeqPQueue *Q){    Q-&gt;size = 0;}</code></pre><p>2.判断非空否</p><pre><code>int QueueNotEmpty(SeqPQueue Q){    if(Q.size &lt;= 0) return 0;    else return 1;}</code></pre><p>3.入队列</p><pre><code>int QueueAppend(SeqPQueue *Q, DataType x){    if(Q-&gt;size &gt;=MaxQueueSize)    {        printf(“队列已满！”);        return 0;    }    else    {        Q-&gt;queue[Q-&gt;size] = x;        Q-&gt;size++;        return 1;    }}</code></pre><p>4.出队列</p><pre><code>int QueueDelete(SeqPQueue *Q, DataType *d){    DataType min;    int minIndex, i;    if(Q-&gt;size &lt;= 0)    {        printf(“队列已空！”);        return 0;    }    else    {        min = Q-&gt;queue[0];      //初始queue[0]为优先级最高元素        minIndex = 0;               //minIndex为优先级最高元素下标        for(i=0; i&lt;Q-&gt;size; i++)    //寻找优先级最高元素对应下标            if(Q-&gt;queue[i].priority &lt;min.priority)            {                min = Q-&gt;queue[i];                minIndex = i;            }            *d = Q-&gt;queue[minIndex];        //找到优先级最高元素            for(i=minIndex+1; i&lt;Q-&gt;size; i++) //数据元素依次前移                Q-&gt;queue[i-1] = q-&gt;queue[i];            Q-&gt;size --;            return 1;    }}</code></pre><p>5.取队列优先级最高元素</p><pre><code>int QueueGet(SeqPQueue *Q, DataType x){    DataType min;    int minIndex, i;    if(Q-&gt;size &lt;= 0)    {        printf(“队列已空！”);        return 0;    }    else    {        min = Q-&gt;queue[0];        minIndex = 0;        for(i=1; i&lt;Q-&gt;size; i++)            if(Q-&gt;queue[i].priority &lt; min.priority)            {                min = Q-&gt;queue[i];                minIndex = i;            }        *d = Q-&gt;queue[minIndex];        return 1;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;队列的基本概念&quot;&gt;&lt;a href=&quot;#队列的基本概念&quot; class=&quot;headerlink&quot; title=&quot;队列的基本概念&quot;&gt;&lt;/a&gt;队列的基本概念&lt;/h1&gt;&lt;p&gt;队列也是一种特殊的线性表，队列的数据元素及数据元素间的逻辑关系和线性表完全相同；其差别在于，线性表允许在任意位置插入和删除数据元素，而队列只允许在其一端进行插入操作，在另一端进行删除操作；进行插入操作的一端称为队尾，允许删除操作的一端称为队头。队列是一种先进先出的线性表。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="https://lxzzzzzxl.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(C语言) —— 堆栈</title>
    <link href="https://lxzzzzzxl.github.io/2019/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(C%E8%AF%AD%E8%A8%80)%20%E2%80%94%E2%80%94%20%E5%A0%86%E6%A0%88/"/>
    <id>https://lxzzzzzxl.github.io/2019/04/10/数据结构(C语言) —— 堆栈/</id>
    <published>2019-04-10T08:24:19.000Z</published>
    <updated>2019-04-10T09:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆栈的基本概念"><a href="#堆栈的基本概念" class="headerlink" title="堆栈的基本概念"></a>堆栈的基本概念</h1><p> 堆栈是一种特殊的线性表，其数据元素以及数据元素间的逻辑关系和线性表的完全相同，其差别是：线性表允许在任意位置插入和删除数据元素，而堆栈只允许在固定一端进行插入和删除数据元素操作。<br> 堆栈中允许进行插入和删除操作的一端成为栈顶，另一端成为栈底；最后进入堆栈的数据元素总是最先退出堆栈，因此堆栈也称作后进先出的线性表。</p><a id="more"></a>  <h1 id="堆栈的顺序表示和实现（顺序堆栈）"><a href="#堆栈的顺序表示和实现（顺序堆栈）" class="headerlink" title="堆栈的顺序表示和实现（顺序堆栈）"></a>堆栈的顺序表示和实现（顺序堆栈）</h1><h2 id="1-顺序堆栈的存储结构"><a href="#1-顺序堆栈的存储结构" class="headerlink" title="1.顺序堆栈的存储结构"></a>1.顺序堆栈的存储结构</h2><p> 定义结构体如下：</p><pre><code>typedef struct{    DataType stack[MaxStackSize];    int top;} SeqStack;</code></pre><h2 id="2-顺序堆栈的操作实现"><a href="#2-顺序堆栈的操作实现" class="headerlink" title="2.顺序堆栈的操作实现"></a>2.顺序堆栈的操作实现</h2><p> 1.初始化</p><pre><code>void StackInitiate(SeqStack *S){    S-&gt;top = 0;            //初始化栈顶下标值（相当于数据元素个数）}</code></pre><p> 2.判断非空否</p><pre><code>int StackNotEmpty(SeqStack S)//非空返回1，空返回0。{    if(S.top &lt;= 0)return 0;    else return 1;}</code></pre><p> 3.入栈</p><pre><code>int StackPush(SeqStack *S, DataType x)//把数据元素值x存入顺序堆栈S中，成功返回1，失败返回0。{    if(S-&gt;top &gt;= MaxStackSize)    {        printf(&quot;堆栈已满，无法入栈！&quot;);        return 0;    }    else    {        S-&gt;stack[S-&gt;top] = x;        S-&gt;top ++;        return 1;    }}</code></pre><p> 4.出栈</p><pre><code>int StackPop(SeqStack *S, DataType *d)//取出的栈顶数据元素值由参数d带回，成功返回1，失败返回0。{    if(S-&gt;top &lt;= 0)    {        printf(&quot;堆栈已空！&quot;);        return 0;    }    else    {        S-&gt;top --;        *d = S-&gt;stack[S-&gt;top];        return 1;    }}</code></pre><p> 5.取栈顶数据元素</p><pre><code>int StackTop(SeqStack S, DataType *d){    if(S.top &lt;= 0)    {        printf(&quot;堆栈已空！&quot;);        return 0;    }    else    {        *d = S.stack[S.top -1];        return 1;    }}</code></pre><h1 id="堆栈的链式表示和实现（链式堆栈）"><a href="#堆栈的链式表示和实现（链式堆栈）" class="headerlink" title="堆栈的链式表示和实现（链式堆栈）"></a>堆栈的链式表示和实现（链式堆栈）</h1><h2 id="1-链式堆栈的存储结构"><a href="#1-链式堆栈的存储结构" class="headerlink" title="1.链式堆栈的存储结构"></a>1.链式堆栈的存储结构</h2><p> 结点结构体定义如下：</p><pre><code>typedef struct snode{    DataType data;    struct snode *next;} LSNode;</code></pre><h2 id="2-链式堆栈的操作实现"><a href="#2-链式堆栈的操作实现" class="headerlink" title="2.链式堆栈的操作实现"></a>2.链式堆栈的操作实现</h2><p> 1.初始化</p><pre><code>void StackInitiate(LSNode **head)//初始化带头结点链式堆栈{    *head = (LSNode *)malloc(sizeof(LSNode));    (*head)-&gt;next = NULL;}</code></pre><p> 2.判断非空否</p><pre><code>int StackNotEmpty(LSNode *head){    if(head-&gt;next == NULL)return 0;    else return 1;}</code></pre><p> 3.入栈</p><pre><code>void StackPush(LSNode *head, DataType x){    LSNode *p;    p = (LSNode *)malloc(sizeof(LSNode));    p-&gt;data = x;    p-&gt;next = head-&gt;next;    head-&gt;next = p;}</code></pre><p> 4.出栈</p><pre><code>int StackPop(LSNode *head, DataType *d){    LSNode *p = head-&gt;next;    if(p == NULL)    {        printf(&quot;堆栈已空！&quot;);        return 0;    }    head-&gt;next = p-&gt;next;    *d = p-&gt;data;    free(p);    return 1;}</code></pre><p> 5.取栈顶数据元素</p><pre><code>int StackTop(LSNode *head, DataType *d){    LSNode *p = head-&gt;next;    if(p == NULL)    {        printf(&quot;堆栈已空!&quot;);        return 0;    }    *d = p-&gt;data;    return 1;}</code></pre><p> 6.撤销动态申请空间</p><pre><code>void Destory(LSNode *head){    LSNode *p, *p1;    p = head;    while(p!=NULL)    {        p1 = p;        p = p-&gt;next;        free(p1);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;堆栈的基本概念&quot;&gt;&lt;a href=&quot;#堆栈的基本概念&quot; class=&quot;headerlink&quot; title=&quot;堆栈的基本概念&quot;&gt;&lt;/a&gt;堆栈的基本概念&lt;/h1&gt;&lt;p&gt; 堆栈是一种特殊的线性表，其数据元素以及数据元素间的逻辑关系和线性表的完全相同，其差别是：线性表允许在任意位置插入和删除数据元素，而堆栈只允许在固定一端进行插入和删除数据元素操作。&lt;br&gt; 堆栈中允许进行插入和删除操作的一端成为栈顶，另一端成为栈底；最后进入堆栈的数据元素总是最先退出堆栈，因此堆栈也称作后进先出的线性表。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆栈" scheme="https://lxzzzzzxl.github.io/tags/%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(C语言) —— 线性表(链表)</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(C%E8%AF%AD%E8%A8%80)%20%E2%80%94%E2%80%94%20%E7%BA%BF%E6%80%A7%E8%A1%A8(%E9%93%BE%E8%A1%A8)/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/30/数据结构(C语言) —— 线性表(链表)/</id>
    <published>2019-03-30T09:06:19.000Z</published>
    <updated>2019-04-10T08:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 上一篇博客我们详细的讲述了顺序表的实现，但以讲述的形式来记录数据结构这部分的笔记效率实在是有些低，所以接下来的部分我就单纯地列出知识点就完事了。嘻嘻嘻！~</p><a id="more"></a>  <h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p> 单链表结点的结构体：</p><pre><code>typedef struct Node{    DataType data;    struct Node *next;} SLNode;其中，data域用来存放数据元素，next域用来存放指向下一结点的指针。</code></pre><p> 单链表还分为带头结点结构和不带头结点结构两种。我们把指向单链表的指针称作头指针，头指针所指的不存放数据元素的第一个结点称作头结点。我们一般构造带头结点的单链表（以下讲解的也是带头结点的单链表）。</p><h2 id="单链表的操作实现"><a href="#单链表的操作实现" class="headerlink" title="单链表的操作实现"></a>单链表的操作实现</h2><h3 id="1-C语言的动态申请内存空间函数"><a href="#1-C语言的动态申请内存空间函数" class="headerlink" title="1.C语言的动态申请内存空间函数"></a>1.C语言的动态申请内存空间函数</h3><p> 要知道，单链表中的每一个结点，是在需要时才向系统申请的，这称作动态内存空间申请。动态申请的内存空间，当不再需要时，必须手动释放。C语言提供了动态申请内存空间的函数malloc()和动态释放函数内存空间的函数free()。这些函数包含在头文件malloc.h中。</p><pre><code>void *malloc(unsigned size);-&gt; 向系统动态申请size个字节的内存单元空间，函数返回值为所申请内存空间的首地址。void free(void *p);-&gt; p为内存空间首地址指针。sizeof(&lt;以定义的数据类型&gt;)-&gt; 计算所需内存空间的大小。</code></pre><h3 id="2-单链表的操作实现"><a href="#2-单链表的操作实现" class="headerlink" title="2.单链表的操作实现"></a>2.单链表的操作实现</h3><p> 1.初始化ListInitiate(SLNode **head)  </p><pre><code>void ListInitiate(SLNode **head)        //初始化{    *head = (SLNode *)malloc(sizeof(SLNode));    //申请头结点，由head指示其地址    (*head)-&gt;next = NULL;                //置结束标记NULL}</code></pre><p> 2.求当前数据元素个数ListLength(SLNode *head)</p><pre><code>int ListInitiate(SLNode *head){    SLNode *p = head;            //p指向头结点    int size = 0;                //size初始化为0    while(p-&gt;next!=NULL)        //循环计数    {        p = p-&gt;next;        size ++;    }    return size;}</code></pre><p> 3.插入ListInsert(SLNode *head, int i, DataType x)</p><pre><code>int ListInsert(SLNode *head, int i, DataType x)//在带头结点的单链表head的第i（0&lt;=i&lt;=size）个结点前//插入一个存放数据元素x的结点。插入成功返回1，失败返回0。{    SLNode *p, *q;    int j;    p = head;    j = -1;    while(p-&gt;next!=NULL &amp;&amp; j&lt;i-1)    //最终让p指向第i-1个结点    {        p = p-&gt;next;        j++;    }    if(j!=i-1)    {        printf(&quot;插入位置参数错误！\n&quot;);        return 0;    }    q = (SLNode *)malloc(sizeof(SLNode));    //生成新的结点    q-&gt;data = x;                            //新节点数据域赋值    q-&gt;next = p-&gt;next;                        //插入    p-&gt;next = q;    return 1;}</code></pre><p> 4.删除ListDelete(SLNode <em>head, int t, DataType </em>x)</p><pre><code>int ListDelete(SLNode *head, int i, DataType *x)//删除带头结点单链表head的第i（0&lt;=i&lt;=size-1）个结点//被删除结点的数据域值由x带回。删除成功返回1，失败返回0。{    SLNode *p, *s;    int j;    p = head;    j = -1;    while(p-&gt;next!=NULL &amp;&amp; p-&gt;next-&gt;next!=NULL &amp;&amp; j&lt;i-1)    //最终p指向第i-1个结点    {        p = p-&gt;next;        j++;    }    if(j!=i-1)    {        printf(&quot;删除位置参数错误！\n&quot;);        return 0;    }    s = p-&gt;next;                //指针s指向第i个结点    *x = s-&gt;data;                //赋值    p-&gt;next = p-&gt;next-&gt;next;    //删除    free(s);                    //释放内存空间    return 1;}</code></pre><p> 5.取数据元素ListGet(SLNode <em>head, int i, DataType </em>x)</p><pre><code>int ListGet(SLNode *head, int i, DataType *x){    SLNode *p;    int j;    p = head;    j = -1;    while(p-&gt;next!=NULL &amp;&amp; j&lt;i)    {        p = p-&gt;next;        j++;    }    if(j!=i)    {        printf(&quot;取元素位置参数错误！\n&quot;);        return 0;    }    *x = p-&gt;data;    return 1;}</code></pre><h1 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h1><p> 链表的最后一个结点的指针域不再是结束标记，而是指向整个链表的第一个结点，从而使链表形成一个环。（与单链表的实现差别不大，不做讨论。）</p><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p> 双向链表也有循环和非循环两种结构，这里讨论带头节点的双向循环链表。<br> 双向循环链表结点的结构体定义如下：</p><pre><code>typedef struct Node{    DataType data;         //数据域    struct Node *next;     //指向后驱结点的指针    struct Node *prior;    //指向前驱结点的指针} DLNode;</code></pre><h2 id="双向循环链表的操作实现"><a href="#双向循环链表的操作实现" class="headerlink" title="双向循环链表的操作实现"></a>双向循环链表的操作实现</h2><p> 1.初始化</p><pre><code>void ListInitiate(DLNode **head){    *head = (DLNode *)malloc(sizeof(DLNode));    (*head)-&gt;prior = *head;    (*head)-&gt;next = *head;}</code></pre><p> 2.插入数据元素</p><pre><code>int ListTnsert(DLNode *head, int i, DataType x)//在带头结点的双向循环链表head的第i（0&lt;=i&lt;=size）个结点前//插入一个存放数据元素x的结点。成功返回1，失败返回0。{    DLNode *p, *s;    int j;    p = head-&gt;next;    j = 0;    while(p-&gt;next!=head &amp;&amp; j&lt;i)            //寻找第i个结点    {        p = p-&gt;next;        j++;     }    if(j!=i)    {        printf(&quot;插入位置参数出错！&quot;);        return 0;    }    s = (DLNode *)malloc(sizeof(DLNode));    s-&gt;data = x;    s-&gt;prior = p-&gt;prior;            //插入步骤    p-&gt;prior-&gt;next = s;    s-&gt;next = p;    p-&gt;prior = s;    return 1;}</code></pre><p> 3.删除数据元素</p><pre><code>int ListDelete()//删除带头结点双向循环链表head的第i（0&lt;=i&lt;=size-1）个结点//被删除的结点的数据元素域值由x带回。成功返回1，失败返回0。{    DLNode *p;    int j;    p = head-&gt;next;    j = 0;    while(p-&gt;next!=head &amp;&amp; j&lt;i)    {        p = p-&gt;next;        j++;    }    if(j!=i)    {        printf(&quot;删除位置参数错误！&quot;);        return 0;    }    p-&gt;prior-&gt;next = p-&gt;next;    p-&gt;next-&gt;prior = p-&gt;prior;    free(p);    return 1;}</code></pre><p> 4.求当前数据元素个数</p><pre><code>int ListLength(DLNode *head){    DLNode *p = head;    int size = 0;    while(p-&gt;next != head)    {        p = p-&gt;next;        size ++;    }    return size;}</code></pre><p> 5.撤销内存空间</p><pre><code>void Destory(DLNode **head){    DLNode *p, *p1;    int i, n = ListLength(*head)    p = *head;    for(i = 0, i&lt;=n, i++)    {        p1 = p;        p = p-&gt;next;        free(p1);    }    *head = NULL;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 上一篇博客我们详细的讲述了顺序表的实现，但以讲述的形式来记录数据结构这部分的笔记效率实在是有些低，所以接下来的部分我就单纯地列出知识点就完事了。嘻嘻嘻！~&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://lxzzzzzxl.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(C语言) —— 线性表(顺序表)</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(C%E8%AF%AD%E8%A8%80)%20%E2%80%94%E2%80%94%20%E7%BA%BF%E6%80%A7%E8%A1%A8(%E9%A1%BA%E5%BA%8F%E8%A1%A8)/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/29/数据结构(C语言) —— 线性表(顺序表)/</id>
    <published>2019-03-29T09:06:19.000Z</published>
    <updated>2019-03-29T15:52:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p> 线性表是一种最简单的数据结构，其主要操作特点是可以在任意位置插入和删除一个数据元素。线性表有两种存储结构分别是顺序存储结构和链式存储结构，前者称为顺序表，后者称为链表，链表主要还分为单链表，循环单链表，双向循环链表三种。本篇我们先讲讲顺序表的实现。  </p><a id="more"></a>  <h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p> 这里涉及到了抽象数据类型的定义（什么是抽象数据类型），简单介绍一下：抽象数据类型是指一个逻辑概念上的类型和这个类型上的操作集合，而类型是一组值的集合。因此线性表的抽象数据类型主要包括两个方面：数据集合和在该数据集合上的操作集合。</p><h3 id="1-数据集合"><a href="#1-数据集合" class="headerlink" title="1.数据集合"></a>1.数据集合</h3><p> 线性表的数据集合可以表示为a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>,…,a<sub>n-1</sub>,每个数据元素的数据类型都是抽象数据元素的数据类型DataType。</p><pre><code>typedef int DataType;</code></pre><h3 id="2-操作集合"><a href="#2-操作集合" class="headerlink" title="2.操作集合"></a>2.操作集合</h3><p> (1) 初始化ListInitiate(L): 初始化线性表L。<br> (2) 求当前数据元素个数ListLength(L): 函数返回线性表L的当前数据元素个数。<br> (3) 插入数据元素ListInsert(L, i, x): 在线性表L的第i个数据元素前插入数据元素x。<br> (4) 删除数据元素ListDelete(L, i, x): 删除线性表L的第i个数据元素。<br> (5) 取数据元素ListGet(L, i, x): 取线性表L的第i个数据元素，由输出参数x带回。</p><h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><p> 接下来我们讲解线性表的第一种存储结构—&gt;顺序存储结构（顺序表）</p><h3 id="顺序表的存储结构"><a href="#顺序表的存储结构" class="headerlink" title="顺序表的存储结构"></a>顺序表的存储结构</h3><p> 我们用结构体表示顺序表的结构，定义结构体SeqList如下：</p><pre><code>typedef struct{    DataType list[MaxSize];    int size;} SeqList;DataType为数组元素（数据元素）的数据类型，MaxSize表示数组的最大元素个数，size表示当前存储元素个数，且有size&lt;=MaxSize,SeqList为结构体名。</code></pre><h3 id="顺序表操作的实现"><a href="#顺序表操作的实现" class="headerlink" title="顺序表操作的实现"></a>顺序表操作的实现</h3><p> (1) 初始化ListInitiate(L)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInitiate</span><span class="params">(SeqList *L)</span><span class="comment">//初始化顺序表L</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L-&gt;size = <span class="number">0</span>;<span class="comment">//定义初始数据元素个数</span></span><br><span class="line">&#125;</span><br><span class="line">【说明】由于函数中要改变参数L的size域的值，所以参数L要设计为输出型参数，即设计为SeqList的指针类型。否则，size域的修改值将不会带回。</span><br></pre></td></tr></table></figure></p><p> (2) 求当前数据元素个数ListLength(L)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.size;返回顺序表L的当前数据元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> (3) 插入数据元素ListInsert(L, i, x)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SeqList *L, <span class="keyword">int</span> i, DataType x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在顺序表L的第i（0&lt;=i&lt;=size）个位置前插入数据元素值x</span></span></span><br><span class="line"><span class="function"><span class="comment">//插入成功返回1，失败返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;size &gt;= MaxSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"顺序表已满无法插入！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;L-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"参数i不合法！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从后向前依次后移数据，为插入做准备</span></span><br><span class="line"><span class="keyword">for</span>(j=L-&gt;size; j&gt;i; j--) L-&gt;size[j] = L-&gt;size[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">L-&gt;<span class="built_in">list</span>[i] = x;<span class="comment">//插入x</span></span><br><span class="line">L-&gt;size ++;    <span class="comment">//元素个数加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> (4) 删除数据元素ListDelete(L, i, x)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SeqList *L, <span class="keyword">int</span> i, DataType *x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除顺序表L中位置i（0&lt;=i&lt;=size-1）上的数据元素并保存到x中</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除成功返回1，失败返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;size &lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"顺序表已空，无数据可删！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">0</span> ||i&gt;L-&gt;size<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"参数i不合法！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*x = L-&gt;<span class="built_in">list</span>[i];<span class="comment">//保存删除的元素到x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从后向前依次前移</span></span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;=L-&gt;size; j++) L-&gt;size[j<span class="number">-1</span>] = L-&gt;size[j];</span><br><span class="line"></span><br><span class="line">L-&gt;size--;<span class="comment">//数据元素个数减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> (5) 取数据元素ListGet(L, i, x)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListGet</span><span class="params">(SeqList L, <span class="keyword">int</span> i, DataType *x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//取顺序表L中第i个数据元素存于x中，成功返回1，失败返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span> ||i&gt;L.size<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"参数i不合法！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*x = L.<span class="built_in">list</span>[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="顺序表应用举例"><a href="#顺序表应用举例" class="headerlink" title="顺序表应用举例"></a>顺序表应用举例</h2><p> 编程实现如下任务：</p><pre><code>建立一个线性表，首先依次输入数据元素1，2，3，...，10，然后删除数据元素5，最后依次显示当前线性表中的数据元素。假设该线性表的数据元素个数在最坏情况下不会超过100个。要求使用顺序表。</code></pre><p> 程序设计如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SeqList mylist;</span><br><span class="line"><span class="keyword">int</span> i, x;</span><br><span class="line"></span><br><span class="line">ListInitiate(&amp;mylist);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">ListInsert(&amp;mylist, i, i+<span class="number">1</span>);</span><br><span class="line">ListDelete(&amp;mylist, <span class="number">4</span>, &amp;x);</span><br><span class="line"><span class="comment">//显示顺序表当前数据元素</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ListLength(mylist); i++)</span><br><span class="line">&#123;</span><br><span class="line">ListGet(mylist, i, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 程序运行结果：</p><pre><code>1 2 3 4 6 7 8 9 10</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h1&gt;&lt;p&gt; 线性表是一种最简单的数据结构，其主要操作特点是可以在任意位置插入和删除一个数据元素。线性表有两种存储结构分别是顺序存储结构和链式存储结构，前者称为顺序表，后者称为链表，链表主要还分为单链表，循环单链表，双向循环链表三种。本篇我们先讲讲顺序表的实现。  &lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://lxzzzzzxl.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://lxzzzzzxl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="顺序表" scheme="https://lxzzzzzxl.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP网络编程 —— 基于TCP的服务器端/客户端</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/23/TCP%20IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E2%80%94%E2%80%94%20%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%20%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/23/TCP IP网络编程 —— 基于TCP的服务器端 客户端/</id>
    <published>2019-03-23T09:41:19.000Z</published>
    <updated>2019-03-23T13:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 前面我们已经学习了创建套接字的函数socket()和向套接字分配地址的函数bind(),接下来我们将正式讨论如何通过套接字收发数据；同时我们之前也介绍了面向连接和面向消息的2种数据传输方式，这篇博客也将具体讨论面向连接的服务器端/客户端的编写。 </p><a id="more"></a>  <h1 id="理解TCP和UDP"><a href="#理解TCP和UDP" class="headerlink" title="理解TCP和UDP"></a>理解TCP和UDP</h1><p> 根据数据传输方式的不同，基于网络协议的套接字一般分为TCP套接字和UDP套接字两种（本篇主要讲解TCP）；因为TCP套接字是面向连接的，因此又称基于流(stream)的套接字。<br> 这里推荐大家自行了解一下TCP/IP协议栈。</p><h1 id="实现基于TCP的服务器端-客户端"><a href="#实现基于TCP的服务器端-客户端" class="headerlink" title="实现基于TCP的服务器端/客户端"></a>实现基于TCP的服务器端/客户端</h1><h2 id="TCP服务器端的默认函数调用顺序"><a href="#TCP服务器端的默认函数调用顺序" class="headerlink" title="TCP服务器端的默认函数调用顺序"></a>TCP服务器端的默认函数调用顺序</h2><p> 绝大部分的TCP服务器端都按照以下的顺序调用函数：</p><pre><code>1. socket()          -&gt;创建套接字2. bind()            -&gt;分配套接字地址3. listen()          -&gt;等待连接请求状态4. accept()          -&gt;允许连接5. read()/write()    -&gt;数据交换6. close()           -&gt;断开连接</code></pre><p> 调用socket函数创建套接字，声明并初始化地址信息结构体变量，调用bind函数向套接字分配地址。这两个阶段之前已经讨论过了，下面讲解之后的几个过程。</p><h3 id="进入等待连接请求状态"><a href="#进入等待连接请求状态" class="headerlink" title="进入等待连接请求状态"></a>进入等待连接请求状态</h3><p> 只有调用了listen函数，客户端才能进入可发出连接请求状态。也就是说，这时客户端才能调用connect函数（提前调用将发生错误）。</p><pre><code>#include &lt;sys/socket.h&gt;int listen(int sock, int backlog);    -&gt;成功时返回0，失败时返回-1。    * sock        进入等待连接请求状态的套接字（服务器端套接字）文件描述符。    * backlog     连接请求等待队列的长度，若为5，则表示最多使5个连接请求进入队列。</code></pre><h3 id="受理客户端连接请求"><a href="#受理客户端连接请求" class="headerlink" title="受理客户端连接请求"></a>受理客户端连接请求</h3><p> 如果调用accept函数，函数将会自动创建一个新的套接字，用来连接到发起请求的客户端。</p><pre><code>#include &lt;sys/socket.h&gt;int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);    -&gt;成功时返回创建的套接字文件描述符，失败时返回-1。    * sock        服务器套接字的文件描述符。    * addr        客户端地址信息的变量地址值。    * addrlen     第二个参数addr结构体的长度，即存有客户端地址长度的的变量地址。</code></pre><h2 id="TCP客户端的默认函数调用顺序"><a href="#TCP客户端的默认函数调用顺序" class="headerlink" title="TCP客户端的默认函数调用顺序"></a>TCP客户端的默认函数调用顺序</h2><pre><code>1. socket()          -&gt;创建套接字2. connect()         -&gt;请求连接3. read()/write()    -&gt;交换数据4. close()           -&gt;断开连接</code></pre><h3 id="请求连接"><a href="#请求连接" class="headerlink" title="请求连接"></a>请求连接</h3><pre><code>#include &lt;sys/socket.h&gt;int connect(int sock, struct sockaddr *servaddr, socklen_t *addrlen);    -&gt;成功时返回0，失败时返回-1。    * sock        客户端套接字文件描述符    * servaddr    保存服务器端地址信息的变量地址值    * addrlen    第二个结构体参数servaddr的地址变量长度</code></pre><p> 客户端调用connect函数后，发生以下情况之一才会返回（完成函数调用）。</p><pre><code>1. 服务器端接收连接请求。2. 发生断网等异常情况而中断连接请求。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> TCP服务器端和客户端两者之间是交互的，并非互相独立，下面我们梳理一下整体流程：</p><pre><code>服务器端创建套接字后连续调用bind，listen函数进入等待状态，客户端创建套接字后调用connect函数发起连接请求。（注意：客户端只有等到服务器端调用listen函数后才能调用connect函数）同时要清楚，客户端调用connect函数之前，服务器端有可能率先调用了accept函数。此时，服务器端在调用accept函数时进入阻塞状态，直到客户端调用connect函数为止。</code></pre><p> 自此，TCP服务器端及客户端的实现和相关函数的说明就已经介绍完了，具体示例可以回看前面几篇博客给出的demo，若还有不明白的地方，请多加复习。<br> 本篇完结，白白~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 前面我们已经学习了创建套接字的函数socket()和向套接字分配地址的函数bind(),接下来我们将正式讨论如何通过套接字收发数据；同时我们之前也介绍了面向连接和面向消息的2种数据传输方式，这篇博客也将具体讨论面向连接的服务器端/客户端的编写。 &lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://lxzzzzzxl.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="套接字" scheme="https://lxzzzzzxl.github.io/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
      <category term="TCP" scheme="https://lxzzzzzxl.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP网络编程 —— 向套接字分配网络地址</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/21/TCP%20IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E2%80%94%E2%80%94%20%E5%90%91%E5%A5%97%E6%8E%A5%E5%AD%97%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/21/TCP IP网络编程 —— 向套接字分配网络地址/</id>
    <published>2019-03-21T13:20:19.000Z</published>
    <updated>2019-03-23T11:51:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 回顾一下服务器端套接字的实现流程，第一步是调用socket函数创建套接字，这个函数我们在上一篇博客已经详细讲解了；第二步则是调用bind函数分配IP地址及端口号，本篇博客就来讲讲bind函数的具体实现。</p><a id="more"></a>  <h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><pre><code>#include &lt;sys/socket.h&gt;int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);    -&gt; 成功时返回0，失败时返回-1。    * sockfd        要分配地址信息（IP地址和端口号）的套接字文件描述符。    * myaddr        存有地址信息的结构体变量地址值。    * addrlen       第二个结构体变量的长度。</code></pre><p> 如果此函数调用成功，则将第二个参数指定的地址信息分配给第一个参数中的相应套接字。下面先看一个服务器端常见的套接字初始化过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> serv_sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> *serv_port = <span class="string">"9190"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建服务器端套接字 */</span></span><br><span class="line">serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 地址信息初始化 */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">serv_addr.sin_port = htons(atoi(serv_port));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配地址信息 */</span></span><br><span class="line">bind(serv_sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br></pre></td></tr></table></figure></p><p> 相信看完这段代码的你，对socket和bind函数的调用并不会有太大的疑问，但你可能对地址信息初始化部分以及bind函数参数是怎么来的会产生很大的困惑，没有关系，我们依旧慢慢道来。</p><h2 id="地址信息的表示"><a href="#地址信息的表示" class="headerlink" title="地址信息的表示"></a>地址信息的表示</h2><p> 一般的，我们把要使用的IP地址和端口号以结构体的形式给出定义，这里用IPv4进行讲解，围绕该结构体讨论目标地址的表示方法：</p><pre><code>表示IPv4地址的结构体：struct sockaddr_in{    sa_family        sin_family;        //地址族（Address Family）    uint6_t          sin_port;          //16位TCP/UDP端口号    struct in_addr   sin_addr;          //32位IP地址    char             sin_zero[8];       //不使用}；</code></pre><p> 该结构体中提到的另一个结构体in_addr定义如下，它用来存放32位IP地址：</p><pre><code>struct in_addr{    In_addr_t        s_addr;            //32位IPv4地址}；</code></pre><p> 下面介绍以上两个结构体的成员变量~</p><h3 id="结构体sockaddr-in的成员分析"><a href="#结构体sockaddr-in的成员分析" class="headerlink" title="结构体sockaddr_in的成员分析"></a>结构体sockaddr_in的成员分析</h3><h4 id="成员sin-family"><a href="#成员sin-family" class="headerlink" title="成员sin_family"></a>成员sin_family</h4><p> 每种协议族适用的地址族均不同。比如，IPv4使用4字节地址族，IPv6使用16字节地址族。</p><pre><code>--------------------------------------------------------------地址族（Address Family）    |              含  义--------------------------------------------------------------    AF_INET                |         IPv4网络协议中使用的地址族    AF_INET6               |         IPv6网络协议中使用的地址族    AF_LOCAL               |     本地通信中采用的UNIX协议的地址族    --------------------------------------------------------------  </code></pre><h4 id="成员sin-port"><a href="#成员sin-port" class="headerlink" title="成员sin_port"></a>成员sin_port</h4><p> 该成员保存16位端口号（以网络字节序保存）。</p><h4 id="成员sin-addr"><a href="#成员sin-addr" class="headerlink" title="成员sin_addr"></a>成员sin_addr</h4><p> 该成员保存32位IP地址信息（也是以网络字节序保存）。</p><h4 id="成员sin-zero"><a href="#成员sin-zero" class="headerlink" title="成员sin_zero"></a>成员sin_zero</h4><p> 该成员无特殊含义，我们只要知道将其填充为0即可。</p><h2 id="网络字节序与地址变换"><a href="#网络字节序与地址变换" class="headerlink" title="网络字节序与地址变换"></a>网络字节序与地址变换</h2><p> 上面我们讲到，结构体sockaddr_in的成员sin_port和sin_addr的数据是以网络字节序保存的，至于什么是网络字节序这里我不进行赘述，大家自行了解，我们只讲字节序的转换；下面介绍两个字节序转换的函数：htons()和htonl()</p><ul><li>htons/htonl中的h代表主机(host)字节序；</li><li>htons/htonl中的n代表网络(network)字节序；</li><li>s指的是short，l指的是long（Linux中long类型占用4字节）；</li><li>htons用于端口号转换，htonl用于IP地址转换；</li></ul><h2 id="网络地址的初始化与分配"><a href="#网络地址的初始化与分配" class="headerlink" title="网络地址的初始化与分配"></a>网络地址的初始化与分配</h2><h3 id="将字符串信息转换为网络字节序的整型数"><a href="#将字符串信息转换为网络字节序的整型数" class="headerlink" title="将字符串信息转换为网络字节序的整型数"></a>将字符串信息转换为网络字节序的整型数</h3><p> 由于sockaddr_in结构体中保存的地址信息的成员为32位整型数，而我们熟悉的IP地址的表示是点分十进制的表示法。因此，在分配IP的时候，需将其表示为32位整型数，下面同样介绍两个函数，它们可以帮助我们将字符串形式的IP地址转换成32位整型数据，且它们在转换类型的同时能够进行网络字节序的转换：</p><pre><code>#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *string);    -&gt;成功时返回32位大端序整数型值，失败时返回INADDR_NONE。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">调用inet_addr函数的demo：</span><br><span class="line"><span class="comment">/* inet_addr.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *addr1=<span class="string">"1.2.3.4"</span>;</span><br><span class="line"><span class="keyword">char</span> *addr2=<span class="string">"1.2.3.256"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> conv_addr=inet_addr(addr1);</span><br><span class="line"><span class="keyword">if</span>(conv_addr==INADDR_NONE)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error occured! \n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#lx \n"</span>, conv_addr);</span><br><span class="line"></span><br><span class="line">conv_addr=inet_addr(addr2);</span><br><span class="line"><span class="keyword">if</span>(conv_addr==INADDR_NONE)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error occured! \n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#lx \n"</span>, conv_addr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>#include &lt;arpa/inet.h&gt;int inet_aton(const char *string, struct in_addr *addr);    -&gt;成功时返回1（true），失败时返回0（false）。    * string            含有需转换的IP地址信息的字符串地址值。    * addr              将保存转换结果的in_addr结构体变量的地址值。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">调用inet_aton函数的demo：</span><br><span class="line"><span class="comment">/* inet_aton.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *addr=<span class="string">"127.232.124.79"</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_inet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!inet_aton(addr,&amp;addr_inet.sin_addr))</span><br><span class="line">error_handling(<span class="string">"Conversion error"</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Network ordered integer addr: %#x \n"</span>, addr_inet.sin_addr.s_addr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面这两个函数的区别在于，若要调用inet_addr函数，需要将转换后的IP地址信息代入sockaddr_in结构体中声明的in_addr结构体变量；而inet_aton函数则不需要此过程，因为传递in_addr结构体变量地址值时，函数会自动把结果传入该结构体变量，因此第二个函数的使用频率更高。</p><p> 再补充一个与inet_aton函数正好相反的函数，此函数可以把网络字节序的整数型IP地址转换为我们熟悉的字符串形式：</p><pre><code>#include &lt;arpa/inet.h&gt;char *inet_ntoa(struct in_addr adr);    -&gt;成功时返回转换的字符串地址值，失败时返回-1。</code></pre><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p> 我们再回顾一下一开始的地址信息初始化代码：</p><pre><code>/* 地址信息初始化1 */memset(&amp;serv_addr, 0, sizeof(serv_addr));serv_addr.sin_family = AF_INET;serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);serv_addr.sin_port = htons(atoi(serv_port));</code></pre><p> 再看另一种初始化方法：</p><pre><code>/* 地址信息初始化2 */memset(&amp;serv_addr, 0, sizeof(serv_addr));serv_addr.sin_family = AF_INET;serv_addr.sin_addr.s_addr = inet_addr(serv_ip);serv_addr.sin_port = htons(atoi(serv_port));</code></pre><p> 经过前面讲解的知识铺垫，我们一句一句来解释地址信息初始化的代码。</p><pre><code>1. memset(&amp;serv_addr, 0, sizeof(serv_addr));    //将每个字节初始化为0，在这里也就是将sin_zero初始化为02. serv_addr.sin_family = AF_INET;              //显而易见，通俗易懂3. serv_addr.sin_port = htons(atoi(serv_port)); //atoi函数把字符串类型的值转换成整数型最后看有差异的第三句，inet_addr(serv_ip)相信大家都好理解，我们主要看htonl(INADDR_ANY)，这是个什么格式？原来，使用inet_addr(serv_ip)，每次都要输入IP地址会有些繁琐，所以可以利用常数INADDR_ANY分配服务器端的IP地址，若采用这种方式，则可自动获取运行服务器端的计算机的IP地址，不必亲自输入。因此，服务器端中优先考虑第二种，而客户端一般不会采用。</code></pre><p> 好啦，讲完啦，白白~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 回顾一下服务器端套接字的实现流程，第一步是调用socket函数创建套接字，这个函数我们在上一篇博客已经详细讲解了；第二步则是调用bind函数分配IP地址及端口号，本篇博客就来讲讲bind函数的具体实现。&lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://lxzzzzzxl.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="套接字" scheme="https://lxzzzzzxl.github.io/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP网络编程 —— 套接字类型与协议设置</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/21/TCP%20IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20%E2%80%94%E2%80%94%20%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/21/TCP IP网络编程 —— 套接字类型与协议设置/</id>
    <published>2019-03-21T04:46:19.000Z</published>
    <updated>2019-03-21T13:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 上一篇博文讲解了Linux下的套接字的实现过程，其中涉及到了一些函数，我们只是直接调用了它们，并没有过多的解释，那么函数的具体用法在这篇博客以及接下来的几篇中将会进行详细的介绍，本篇介绍的是创建套接字的函数socket()。</p><a id="more"></a> <h1 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h1><pre><code>#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);    -&gt; 成功时返回文件描述符，失败时返回-1。    * domain      套接字中使用的协议族（Protocol Family）信息。    * type        套接字数据传输类型信息。    * protocol    计算机间通信中使用的协议信息。</code></pre><p> 相信看过前一篇的对这个函数并不陌生，但是对函数中的这几个参数可能就不是很明白了，没有关系，我们慢慢道来。</p><h2 id="协议族（Protocol-Famliy）"><a href="#协议族（Protocol-Famliy）" class="headerlink" title="协议族（Protocol Famliy）"></a>协议族（Protocol Famliy）</h2><p> 奶油意大利面和番茄意大利面都属于意大利面的一种，相似的，套接字通信中的协议也是有分类的。socket函数的第一个参数就是传递套接字中使用的协议分类信息。此协议分类信息我们便称之为协议族，可分成如下几类：</p><pre><code>-------------------------------------------------名 称                        协 议 族-------------------------------------------------PF_INET                     IPv4互联网协议族PF_INET6                    IPv6互联网协议族PF_LOCAL                    本地通信的UNIX协议族PF_PACKET                   底层套接字的协议族PF_IPX                      IPX Novell协议族</code></pre><p> 以上的协议族在头文件sys/socket.h中声明；另外我们将重点放在PF_INET对应的IPv4互联网协议族上，因为其他协议族并不常用或尚未普及。</p><h2 id="套接字类型（Type）"><a href="#套接字类型（Type）" class="headerlink" title="套接字类型（Type）"></a>套接字类型（Type）</h2><p> 套接字类型指的是套接字的数据传输方式，由socket函数的第二个参数传递；下面介绍2种具有代表性的数据传输方式：</p><h3 id="套接字类型1：面向连接的套接字（SOCK-STREAM）"><a href="#套接字类型1：面向连接的套接字（SOCK-STREAM）" class="headerlink" title="套接字类型1：面向连接的套接字（SOCK_STREAM）"></a>套接字类型1：面向连接的套接字（SOCK_STREAM）</h3><p> 如果向socket函数的第二个参数传递SOCK_STREAM，将创建面向连接的套接字，此传输方式的特征如下：</p><ul><li>传输过程中数据不会消失</li><li>按序传输数据</li><li>传输的数据不存在数据边界</li></ul><h3 id="套接字类型2：面向消息的套接字（SOCK-DGRAM）"><a href="#套接字类型2：面向消息的套接字（SOCK-DGRAM）" class="headerlink" title="套接字类型2：面向消息的套接字（SOCK_DGRAM）"></a>套接字类型2：面向消息的套接字（SOCK_DGRAM）</h3><p> 如果向socket函数的第二个参数传递SOCK_DGRAM,将创建面向消息的套接字，此传输方式的特征如下：</p><ul><li>强调快速传输而非传输顺序</li><li>传输的数据可能丢失也可能损毁</li><li>传输的数据有数据边界</li><li>限制每次传输的数据大小</li></ul><p>注：面向连接的套接字需要有相同类型的另一套接字与之连接，而面向消息的套接字不存在连接的概念。</p><h2 id="协议的最终选择"><a href="#协议的最终选择" class="headerlink" title="协议的最终选择"></a>协议的最终选择</h2><p> 下面讲解socket函数的第三个参数，该参数决定最终采用的协议；在大部分情况下，传递前两个参数即可创建所需的套接字，所以可以向第三个参数传递0；如果数据传输方式相同，但协议不同，则此时需要通过第三个参数指定具体的协议信息。下面用两个例子来理解第三个参数。<br> 创建满足如下要求的套接字：</p><pre><code>1.“IPv4协议族中面向连接的套接字”很明显，前两个参数就是PF_INET和SOCK_STREAM了，而满足前两个条件的协议就只有IPPROTO_TCP了，因此我们可以向第三个参数传递0或是如下格式：int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);  2.&quot;IPv4协议族中面向消息的套接字&quot;同样的，前两个参数就是PF_INET和SOCK_DGRAM,满足前两个条件的协议只有IPPROTO_UDP,所以该套接字如下：int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);</code></pre><p>自此，整个socket函数就算是讲解完了，大家可以回过头去看看前一篇博客给出的demo，相信你们对socket函数部分会比之前有更深的理解。<br>本篇完结，白白。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 上一篇博文讲解了Linux下的套接字的实现过程，其中涉及到了一些函数，我们只是直接调用了它们，并没有过多的解释，那么函数的具体用法在这篇博客以及接下来的几篇中将会进行详细的介绍，本篇介绍的是创建套接字的函数socket()。&lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://lxzzzzzxl.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="套接字" scheme="https://lxzzzzzxl.github.io/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP网络编程 —— 套接字(socket)</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/19/TCP%20IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E5%A5%97%E6%8E%A5%E5%AD%97(socket)/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/19/TCP IP网络编程—套接字(socket)/</id>
    <published>2019-03-18T16:01:19.000Z</published>
    <updated>2019-03-19T12:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 做嵌入式物联网的，不学点网络编程好像有点说不过去，暑假学的RT-Thread的网络编程仅仅是了解了怎么用，可以说是知其然却不知其所以然，所以还是老老实实从基础开始，学一遍网络编程吧，挑了网友推荐的《TCP/IP网络编程》，感觉还不错。看了第一章，学习了Linux和Windows下的socket编程相关函数，本篇博客就简单的对Linux下的socket创建过程做下笔记。</p><a id="more"></a>  <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p> 首先还是要介绍一下基础概念，所谓网络编程，简单来说就是编写程序使两台联网的计算机相互交换数据，而套接字呢，你可以理解为计算机连接网络的工具，进而引申为两台计算机之间的网络连接。<br> 套接字大致还可以分为两种，一种是服务器端(server)的套接字，一种是客户端(client)的套接字，下面我们就对这两种套接字的创建过程及使用方法作详细的介绍。  </p><h2 id="服务器端-server-套接字"><a href="#服务器端-server-套接字" class="headerlink" title="服务器端(server)套接字"></a>服务器端(server)套接字</h2><p> 两台计算机要进行通信/数据交换，那么作为服务器端的计算机要做什么事情呢？自然是等待(监听)接受连接请求了，这个过程可归纳为以下四步：</p><p> 第一步：调用socket函数创建套接字。  </p><pre><code>#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);-&gt; 成功时返回文件描述符，失败时返回-1。</code></pre><p> 第二步：调用bind函数分配IP地址和端口号。</p><pre><code>#include &lt;sys/socket.h&gt;int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);-&gt; 成功时返回0，失败时返回-1。</code></pre><p> 第三步：调用listen函数转为可接收请求状态。</p><pre><code>#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);-&gt; 成功时返回0，失败时返回-1。</code></pre><p> 第四步：调用accept函数受理连接请求。</p><pre><code>#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);-&gt; 成功时返回文件描述符，失败时返回-1。</code></pre><h2 id="客户端-client-套接字"><a href="#客户端-client-套接字" class="headerlink" title="客户端(client)套接字"></a>客户端(client)套接字</h2><p> 那么客户端套接字，也就是请求连接服务器的套接字，它的创建比服务器端套接字简单多了，只有以下两步：  </p><p> 第一步：调用socket函数创建套接字。</p><pre><code>#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);-&gt; 成功时返回文件描述符，失败时返回-1。</code></pre><p> 第二步：调用connect函数向服务器端发送连接请求。</p><pre><code>#include &lt;sys/socket.h&gt;int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addrlen);-&gt; 成功时返回0，失败时返回-1。</code></pre><h1 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h1><p> 通过调用上述介绍的函数，就可以编写自己的server/client程序进行模拟通讯啦，下面贴上两个Linux下的demo程序让大家理解整个过程的实现。</p><h2 id="“Hello-World！”服务器端demo"><a href="#“Hello-World！”服务器端demo" class="headerlink" title="“Hello World！”服务器端demo"></a>“Hello World！”服务器端demo</h2><p> 服务器端（server）是能够受理连接请求的程序。下面demo构建的服务器收到连接请求后向请求者返回“Hello World!”答复。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello_server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> serv_sock;</span><br><span class="line"><span class="keyword">int</span> clnt_sock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> message[]=<span class="string">"Hello World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serv_sock=socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//调用socket函数创建套接字。</span></span><br><span class="line"><span class="keyword">if</span>(serv_sock == <span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">serv_addr.sin_family=AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">serv_addr.sin_port=htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bind(serv_sock, (struct sockaddr*) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)<span class="comment">//调用bind函数分配IP地址和端口号。</span></span><br><span class="line">error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(listen(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>)<span class="comment">//调用listen函数将套接字转为可接收连接状态。</span></span><br><span class="line">error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line"></span><br><span class="line">clnt_addr_size=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">clnt_sock=accept(serv_sock, (struct sockaddr*) &amp;clnt_addr, &amp;clnt_addr_size);<span class="comment">//调用accept函数受理连接请求。如果在没有连接请求的的情况下调用该函数，则不会返回，直到有连接请求为止。</span></span><br><span class="line"><span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line"></span><br><span class="line">write(clnt_sock, message, <span class="keyword">sizeof</span>(message));<span class="comment">//数据传输函数</span></span><br><span class="line">close(clnt_sock);</span><br><span class="line">close(serv_sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="客户端demo"><a href="#客户端demo" class="headerlink" title="客户端demo"></a>客户端demo</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello_client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> str_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;IP&gt; &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sock=socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//创建套接字，但此时套接字并不马上分为服务器端和客户端。如果紧接着调用bind，listen函数，将成为服务器端套接字；如果调用connect函数，将成为客户端套接字。</span></span><br><span class="line"><span class="keyword">if</span>(sock == <span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">serv_addr.sin_family=AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">serv_addr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(connect(sock, (struct sockaddr*) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)<span class="comment">//调用connect函数向服务器端发送连接请求。</span></span><br><span class="line">error_handling(<span class="string">"connect() error"</span>);</span><br><span class="line"></span><br><span class="line">str_len=read(sock, message, <span class="keyword">sizeof</span>(message)<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(str_len==<span class="number">-1</span>)</span><br><span class="line">error_handling(<span class="string">"read() error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Message from server : %s \n"</span>, message);</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">fputc(<span class="string">'\n'</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_server.c -o hserver</span><br><span class="line">-&gt;编译 hello_server.c文件并生成可执行文件hserver。</span><br><span class="line">./hserver <span class="number">9190</span></span><br><span class="line">-&gt;运行当前目录下的hserver文件</span><br><span class="line">运行结果：等待客户端连接。</span><br><span class="line">gcc hello_client.c -o hclient</span><br><span class="line">-&gt;编译......</span><br><span class="line">./hclient <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">9190</span></span><br><span class="line">-&gt;运行......</span><br><span class="line">运行结果：Hello World!</span><br></pre></td></tr></table></figure><p>本篇完结，谢谢观看，白了个白。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 做嵌入式物联网的，不学点网络编程好像有点说不过去，暑假学的RT-Thread的网络编程仅仅是了解了怎么用，可以说是知其然却不知其所以然，所以还是老老实实从基础开始，学一遍网络编程吧，挑了网友推荐的《TCP/IP网络编程》，感觉还不错。看了第一章，学习了Linux和Windows下的socket编程相关函数，本篇博客就简单的对Linux下的socket创建过程做下笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://lxzzzzzxl.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="套接字" scheme="https://lxzzzzzxl.github.io/tags/%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>C语言排序算法复习</title>
    <link href="https://lxzzzzzxl.github.io/2019/03/01/C%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    <id>https://lxzzzzzxl.github.io/2019/03/01/C语言排序算法复习/</id>
    <published>2019-03-01T05:41:19.000Z</published>
    <updated>2019-03-01T12:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前还在不紧不慢的状态中，转眼间找实习就开始了，第一个目标是CVTE的嵌入式软件开发实习生的岗位，昨天刚刚网申，听了宣讲会，明天就要参加在线测评了（还是广州站的最后一次机会……），时间很紧，抓紧时间复习一下一些知识点，看过一点往年试题，排序算法部分考得挺多，便整理了一下。  </p><a id="more"></a>  <h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p> <strong>基本思想：比较相邻的两个数，如果前者比后者大，则进行交换。每一轮排序结束，选出一个未排序中最大的数放到数组后面。若数组长度为n，则需进行n-1轮排序才能得出结果。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 冒泡排序算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr ,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)                         <span class="comment">//进行n-1轮排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)                   <span class="comment">//对未排序部分进行排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[j+<span class="number">1</span>];             <span class="comment">//比较交换</span></span><br><span class="line">arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">arr[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data[]=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);        <span class="comment">//计算数组长度</span></span><br><span class="line">bubbleSort(data,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组长度为：%d\n"</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"排序后的数组为：\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n;a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,data[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p> <strong>基本思想：和交换排序不同的是它不用进行交换操作，而是用一个临时变量存储当前值。当前面的元素比后面大时，先把后面的元素存入临时变量，前面元素的值放到后面元素位置，再到最后把其值插入到合适的数组位置。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">j=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;arr[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line"><span class="keyword">while</span>(temp&lt;arr[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">arr[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); </span><br><span class="line">InsertSort(arr,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数组长度为：%d\n"</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"排序后的数组为:\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h1><p> <strong>基本思想：依次选出数组最小的数放到数组的前面。首先从数组的第二个元素开始往后遍历，找出最小的数放到第一个位置。再从剩下数组中找出最小的数放到第二个位置。以此类推，直到数组有序。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> key=i;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[key])</span><br><span class="line">&#123;</span><br><span class="line">key=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(key!=i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[key];arr[key]=arr[i];arr[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[]=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);        <span class="comment">//计算数组长度</span></span><br><span class="line">    SelectSort(data,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数组长度为：%d\n"</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序后的数组为：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;n;a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,data[a]);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完结，继续复习，白了个白。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前还在不紧不慢的状态中，转眼间找实习就开始了，第一个目标是CVTE的嵌入式软件开发实习生的岗位，昨天刚刚网申，听了宣讲会，明天就要参加在线测评了（还是广州站的最后一次机会……），时间很紧，抓紧时间复习一下一些知识点，看过一点往年试题，排序算法部分考得挺多，便整理了一下。  &lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="https://lxzzzzzxl.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="排序算法" scheme="https://lxzzzzzxl.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AT指令下的W600-GET-简单的天气信息（心知天气）</title>
    <link href="https://lxzzzzzxl.github.io/2019/02/15/AT%E6%8C%87%E4%BB%A4%E4%B8%8B%E7%9A%84W600-GET-%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%A9%E6%B0%94%E4%BF%A1%E6%81%AF%EF%BC%88%E5%BF%83%E7%9F%A5%E5%A4%A9%E6%B0%94%EF%BC%89/"/>
    <id>https://lxzzzzzxl.github.io/2019/02/15/AT指令下的W600-GET-简单的天气信息（心知天气）/</id>
    <published>2019-02-15T14:25:19.000Z</published>
    <updated>2019-02-15T15:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自从春节以来，学习就不在状态，一直想做好久了的百度语音识别项目迟迟没有进展，断断续续看了好多文档和资料，就是不知从何下手，今天写的这篇博客没有太大的目的，就是想让自己找回状态，脉动回来，哈哈哈！就写一个W600调用心知天气API吧，AT指令下的，很简单。  </p><a id="more"></a><h1 id="心知天气使用"><a href="#心知天气使用" class="headerlink" title="心知天气使用"></a>心知天气使用</h1><p>简单说一下：<br>1.首先，老套路，去注册一个心知天气账号，（有免费会员和付费的给你选）获取你的API密钥，后面会用到。<br>2.紧接着，看一个示例：</p><p> <img src="https://i.imgur.com/Q3Fv1mb.png" alt> </p><p> 这是一个免费的天气API,双击如下示例URL或者复制粘贴到浏览器可以看到返回结果：<br> <a href="https://api.seniverse.com/v3/weather/now.json?key=6dxwrt9yzsyj3vmr&amp;location=beijing&amp;language=zh-Hans&amp;unit=c" target="_blank" rel="noopener">https://api.seniverse.com/v3/weather/now.json?key=6dxwrt9yzsyj3vmr&amp;location=beijing&amp;language=zh-Hans&amp;unit=c</a> </p><pre><code>{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;北京,北京,中国&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;+08:00&quot;},&quot;now&quot;:{&quot;text&quot;:&quot;晴&quot;,&quot;code&quot;:&quot;1&quot;,&quot;temperature&quot;:&quot;-3&quot;},&quot;last_update&quot;:&quot;2019-02-15T22:45:00+08:00&quot;}]}</code></pre><h1 id="W600-GET-API"><a href="#W600-GET-API" class="headerlink" title="W600 GET API"></a>W600 GET API</h1><p>当然啦，上面讲的是在PC端简单的调用API给大家看看现象，我们要做的是通过W600,GET到服务器上的信息，我们用AT指令来实现：<br>1.首先将W600设置为STA模式连接上路由器<br>2.接着连接心知天气服务器  </p><pre><code>AT+CIPSTART=&quot;TCP&quot;,&quot;api.seniverse.com&quot;,80</code></pre><p>3.设置为透传模式</p><pre><code>AT+CIPMODE=1</code></pre><p>4.开启透传</p><pre><code>AT+CIPSEND</code></pre><p>5.发送GET+URL</p><pre><code>GET https://api.seniverse.com/v3/weather/now.json?key=6dxwrt9yzsyj3vmr&amp;location=beijing&amp;language=zh-Hans&amp;unit=c</code></pre><p>现象如下：</p><p><img src="https://i.imgur.com/gZnN0nB.png" alt></p><p>此处返回的天气信息跟PC端的试验其实是一样的，只是在串口助手中文显示为乱码而已。</p><p>注：本篇博客只是初略的介绍了如何在AT指令下GET服务器信息，涉及更多心知天气的内容以及网络编程的知识，请大家自行了解。</p><p>本篇完结！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;自从春节以来，学习就不在状态，一直想做好久了的百度语音识别项目迟迟没有进展，断断续续看了好多文档和资料，就是不知从何下手，今天写的这篇博客没有太大的目的，就是想让自己找回状态，脉动回来，哈哈哈！就写一个W600调用心知天气API吧，AT指令下的，很简单。  &lt;/p&gt;
    
    </summary>
    
      <category term="WIFI" scheme="https://lxzzzzzxl.github.io/categories/WIFI/"/>
    
    
      <category term="W600" scheme="https://lxzzzzzxl.github.io/tags/W600/"/>
    
  </entry>
  
  <entry>
    <title>百度AI — 语音识别</title>
    <link href="https://lxzzzzzxl.github.io/2019/02/03/%E7%99%BE%E5%BA%A6AI%20%E2%80%94%20%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    <id>https://lxzzzzzxl.github.io/2019/02/03/百度AI — 语音识别/</id>
    <published>2019-02-03T13:12:19.000Z</published>
    <updated>2019-02-03T14:49:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 自寒假开始学习RT-Thread操作系统以来，已经完成了对基础内核部分以及QEMU网络编程的学习；从一开始对逐渐火起来的RT-Thread的好奇，到刚开始接触时的一脸懵逼，到现在的感叹RT-Thread的强大，真是深深体会到不断学习的重要性；今天的这篇博客是做QEMU网络编程结课作业时学习到的一点小内容，主要是对百度语音识别API的使用：</p><a id="more"></a><h1 id="百度语音识别"><a href="#百度语音识别" class="headerlink" title="百度语音识别"></a>百度语音识别</h1><p> 百度语音识别简单来说就是百度AI通过API的方式给开发者提供一个通用的HTTP接口，开发者通过这个接口上传音频文件，返回识别结果；通过学习使用百度语音识别API，我们就可以做一个语音控制单片机继而控制外设的设计，这也是我接下来要做的，做一个能交互的语音控制设计，想想就很酷！<br> 首先我们要注册一个百度开发者账号，然后创建一个语音识别的应用，这部分大家自行百度~  </p><h1 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h1><h2 id="1-获取-Access-Token："><a href="#1-获取-Access-Token：" class="headerlink" title="1.获取 Access Token："></a>1.获取 Access Token：</h2><p>（这里推荐一个软件：Postman，貌似要翻墙，大家自行了解）<br>向授权服务地址 <a href="https://aip.baidubce.com/oauth/2.0/token" target="_blank" rel="noopener">https://aip.baidubce.com/oauth/2.0/token</a> 发送请求（推荐使用POST），并在URL中带上以下参数：</p><ul><li>grant_type： 必须参数，固定为client_credentials；</li><li>client_id： 必须参数，应用的API Key；</li><li>client_secret： 必须参数，应用的Secret Key；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例： </span><br><span class="line">https://openapi.baidu.com/oauth/2.0/token? grant_type=client_credentials&amp;client_id=Va5yQRHl********LT0vuXV4&amp;client_secret= 0rDSjzQ20XUj5i********PQSzr5pVw2&amp;</span><br></pre></td></tr></table></figure><p>下图为使用Postman:<br><img src="https://i.imgur.com/WkhTJNl.jpg" alt></p><h2 id="使用Access-Token进行语音识别"><a href="#使用Access-Token进行语音识别" class="headerlink" title="使用Access Token进行语音识别"></a>使用Access Token进行语音识别</h2><p>采用Raw方式，详见下图：<br><img src="https://i.imgur.com/c5fcDkj.png" alt><br><img src="https://i.imgur.com/qiFBayp.png" alt></p><p>更多详细内容，大家参考百度AI文档中心的相关部分<a href="https://ai.baidu.com/docs#/ASR-API/77e2b22e" target="_blank" rel="noopener">https://ai.baidu.com/docs#/ASR-API/77e2b22e</a> ，相信各位看完文档再来看本篇博客会豁然开朗~<br>本片完结！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 自寒假开始学习RT-Thread操作系统以来，已经完成了对基础内核部分以及QEMU网络编程的学习；从一开始对逐渐火起来的RT-Thread的好奇，到刚开始接触时的一脸懵逼，到现在的感叹RT-Thread的强大，真是深深体会到不断学习的重要性；今天的这篇博客是做QEMU网络编程结课作业时学习到的一点小内容，主要是对百度语音识别API的使用：&lt;/p&gt;
    
    </summary>
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/categories/STM32/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
      <category term="百度AI" scheme="https://lxzzzzzxl.github.io/tags/%E7%99%BE%E5%BA%A6AI/"/>
    
  </entry>
  
  <entry>
    <title>正点原子—按键输入代码解析</title>
    <link href="https://lxzzzzzxl.github.io/2019/01/27/%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E2%80%94%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lxzzzzzxl.github.io/2019/01/27/正点原子—按键输入代码解析/</id>
    <published>2019-01-27T04:12:19.000Z</published>
    <updated>2019-01-28T10:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信很多人学习STM32看的教程资料什么的，不是正点原子就是野火，这两家的资料都是比较有名的，我用的就是正点原子的，这篇博客我来讲一下我当初学习按键输入例程时的疑惑，我到论坛上看了，大部分初学者跟我有同样的问题，究尽是什么问题呢？我们先上代码：  </p><a id="more"></a>  <h1 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">static</span> u8 key_up=<span class="number">1</span>;<span class="comment">//按键按松开标志</span></span><br><span class="line"><span class="keyword">if</span>(mode)key_up=<span class="number">1</span>;  <span class="comment">//支持连按  </span></span><br><span class="line"><span class="keyword">if</span>(key_up&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//去抖动 </span></span><br><span class="line">key_up=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(KEY1==<span class="number">0</span>)<span class="keyword">return</span> KEY_1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)<span class="keyword">return</span> KEY_2;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>)key_up=<span class="number">1</span>;     </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就出在这个KEY_Scan()函数上（上面贴的代码我修改过，原版是有4个按键的，我改成2个，但实质上是一样的，这样方便大家理解），前面GPIO初始化部分，相信看过跑马灯例程过来的都没什么问题，我们主要看看KEY_Scan()这个函数，这个函数是带参数mode的，且有返回值，当初我跟大部分网友的疑惑在于为啥mode为1就支持连续按，为0就不支持呢，原理是啥？代码读一遍下来感觉为0为1没差啊。<br>为什么会有这样的疑惑，归结起来还是C语言基础太差，还有一个很重要的原因就是，大家阅读代码就只是这样读一遍下来，然而这里你要读上两遍才能看出问题所在。下面我们一点一点来讲……<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> u8 key_up=<span class="number">1</span>;<span class="comment">//按键按松开标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这句话咋一看没什么了不起，不就是定义key_up的值为1吗？是这样没错，但是大家可能忽视了前面</span></span><br><span class="line"><span class="comment">有个static，或者知道有static却不知道它的含义，这就是为什么我说C语言基础差的原因，static用</span></span><br><span class="line"><span class="comment">在这里相当于定义了一个static局部变量，下面是重点：static局部变量只被初始化一次，下一次依据</span></span><br><span class="line"><span class="comment">上一次结果值。意思也就是说，这句话只跑一次！！！ */</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mode)</span><br><span class="line">key_up=<span class="number">1</span>;  <span class="comment">//是否支持连按 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里我把原代码这样写，可能大家见这样形式的比较熟悉，很明显是个if判断语句，如果是真，执行</span></span><br><span class="line"><span class="comment">key_up=1；如果不为真，跳过，执行下一行；那么真不真，相信大家应该都明白，1真0不真咯，如果不</span></span><br><span class="line"><span class="comment">懂，还是先去翻翻C语言吧。 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key_up&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);<span class="comment">//去抖动 </span></span><br><span class="line">key_up=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(KEY1==<span class="number">0</span>)<span class="keyword">return</span> KEY_1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)<span class="keyword">return</span> KEY_2;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>)key_up=<span class="number">1</span>;     </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无按键按下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 剩下的我们合在一起看，前面我们定义了按键松开标志key_up=1，如果满足key_up为真且KEY1或</span></span><br><span class="line"><span class="comment">KEY2有一个为0（被按下为0），那么我们就把按键标志key_up置0，同时判断是哪个键被按下，然后输</span></span><br><span class="line"><span class="comment">出返回值；如果KEY1,KEY2都没被按下，则key_up还是置1，返回0。 */</span></span><br></pre></td></tr></table></figure><p> 好了，以上基本代码已经讲解完了，可能有的人已经领悟了问题所在，有的人还迷迷糊糊，没关系，我们接下来直击重点：<br> 没有明白的人，我相信只剩逻辑问题了，我们代码中有这样一句话<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key_up&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p> 这句代码告诉我们，你想知道哪个键被按下不仅仅是判断是否有按键被按下这么简单，还要满足按键标志key_up为1才行；如果你不想支持连按，即mode=0，因为我们初始了key_up=1，当我们按下按键，确实能成功响应返回值，但同时key_up也被置0，如果你的手不放开，程序是永远无法进入下一次按键判断的，因为此时key_up为0，不满足条件；只有当你把手放开，程序执行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>)key_up=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p> 这时key_up才被重新置1，下一次按键才能被检测判断，这就是所谓的不支持连按。</p><p> 那么如果你是想支持连按的，因为mode=1，程序每次跑，判断到mode=1，为真，就自动将key_up置1了，尽管你的手不放开，程序都能进入按键检测，你一直按着哪个键，它就不停返回对应的返回值，这就是所谓的支持连按。  </p><p>完结！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;相信很多人学习STM32看的教程资料什么的，不是正点原子就是野火，这两家的资料都是比较有名的，我用的就是正点原子的，这篇博客我来讲一下我当初学习按键输入例程时的疑惑，我到论坛上看了，大部分初学者跟我有同样的问题，究尽是什么问题呢？我们先上代码：  &lt;/p&gt;
    
    </summary>
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/categories/STM32/"/>
    
      <category term="正点原子" scheme="https://lxzzzzzxl.github.io/categories/STM32/%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>STM32F103 UCGUI3.90移植+触摸屏教程</title>
    <link href="https://lxzzzzzxl.github.io/2019/01/24/STM32F103%20UCGUI3.90%E7%A7%BB%E6%A4%8D+%E8%A7%A6%E6%91%B8%E5%B1%8F%E6%95%99%E7%A8%8B/"/>
    <id>https://lxzzzzzxl.github.io/2019/01/24/STM32F103 UCGUI3.90移植+触摸屏教程/</id>
    <published>2019-01-24T11:12:19.000Z</published>
    <updated>2019-01-28T10:18:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 这是大二暑假学习STM32时写的一篇的教程，当初移植的时候耗费了好大的力气，集齐了万千网友的智慧和教程，归纳总结整理出来的，在此记录一下。</p><a id="more"></a>  <h1 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一.准备工作"></a>一.准备工作</h1><p>1.采用UCGUI3.90版本———下载UCGUI3.90.zip。  <a href="/download/UCGUI3.90.zip">点击下载</a></p><p>2.准备好自己的LCD驱动程序。</p><p>3.自行新建一个工程模板（本人采用的是正点原子战舰开发板的TFTLCD显示实验例程作为模板）备用。</p><p>4.解压打开UCGUI文件夹，1）将Start文件夹中的Config和GUI文件夹复制粘贴到自己的工程文件中。2）将Sample\GUI_X中的GUI_X.C复制粘贴到Config中。 </p><p><img src="https://i.imgur.com/OM6TO9c.png" alt><br><img src="https://i.imgur.com/jxWOjk4.png" alt>  </p><p>5.由于UCGUI\Core下有LCD.C和LCD.H文件，而例程中也有，为了防止重复，需将原工程中的LCD.C和LCD.H修改为其他名称，例：ILI93XX.C ILI93XX.H</p><p>6.修改ILI93XX.C中的LCD初始化函数LCD_Init，将其改为TFTLCD_Init（名称自定）</p><p>7.将ILI93XX.H中原LCD改为TFTLCD,全局修改。  </p><p><img src="https://i.imgur.com/P7AC9Gk.png" alt></p><h1 id="二．开始移植"><a href="#二．开始移植" class="headerlink" title="二．开始移植"></a>二．开始移植</h1><p>1.将文件添加进工程</p><p><img src="https://i.imgur.com/ZCeM8YD.png" alt><br>2.添加路径</p><p><img src="https://i.imgur.com/FhZ2wTk.png" alt><br>3.接下来需要修改三个文件GUIConf.h   LCDConf.h   LCDDummy.c  </p><p>1）首先修改GUIConf.h，将其修改为如下图所示</p><p><img src="https://i.imgur.com/e3BuHXn.png" alt></p><p>2）修改LCDConf.h  </p><p><img src="https://i.imgur.com/IzHISp9.png" alt></p><p>3）修改LCDDummy.c（LCDDriver下有三个文件都是模板，修改其中一个即可，我们以LCDDummy.c为例）主要是对函数进行优化</p><blockquote><p><strong>找到void LCD_L0_SetPixelIndex(int x, int y, int PixelIndex)，添加自己的画点函数</strong></p></blockquote><p><img src="https://i.imgur.com/0X2qTuG.png" alt></p><blockquote><p><strong>找到unsigned int LCD_L0_GetPixelIndex(int x, int y)，添加自己的读点函数</strong></p></blockquote><p><img src="https://i.imgur.com/5y8JHbF.png" alt></p><p>在这里主要优化以上两个函数，大家可以根据自己的需要自行优化<br>注意，下面这句话需要注释掉，不然文件不会编译，同时需要include ”ili93xx.h“</p><p><img src="https://i.imgur.com/PG528ek.png" alt></p><p>经过以上几布的移植，UCGUI已经可以使用了（不包括触摸屏）。  </p><h1 id="移植触摸屏"><a href="#移植触摸屏" class="headerlink" title="移植触摸屏"></a>移植触摸屏</h1><p>1.准备好触摸屏的驱动文件（本人用的是touch.c 和touch.h），添加到工程中。<br>2.将Sample\GUI_X中的GUI_X_Touch.c复制粘贴到Config中，再添加到工程中。<br>3.在GUIConf.h下修改。       </p><pre><code class="C"><span class="meta">#<span class="meta-keyword">define</span> GUI_SUPPORT_TOUCH         (1) </span></code></pre><p>4.接下来需要配置几个文件，首先是:<br> 1）GUITouchConf.h<br><img src="https://i.imgur.com/w4T4l3e.png" alt>  </p><p>GUI_TOUCH_AD_LEFT, GUI_TOUCH_AD_RIGHT, GUI_TOUCH_AD_TOP, GUI_TOUCH_AD_BOTTOM 这四个的值需要实测，测量方法自行百度。  </p><p> 2）GUI_X_Touch.c<br><img src="https://i.imgur.com/DZ72dzc.png" alt><br>上图4个函数前两个无需配置，按上图形式在后两个函数中添加你的读X轴，读Y轴函数TPReadX( )，TPReadY( )  </p><p>5.由于我们没有移植UC/OSII，不支持任务，所以需要靠定时刷新GUI_TOUCH_Exec( ) 这个函数，驱动函数获取坐标值重绘窗口，方法是在定时器中断TIMx_IRQHandler中加入GUI_TOUCH_Exec( )，GUI_Exec( )，实现坐标获取（添加timer.c和timer.h）<br><img src="https://i.imgur.com/nCgCHvs.png" alt></p><p>6.经过以上几步，触摸屏移植完成 注意：触摸屏初始化SPI_Config( )要在定时器初始化TIM6_Int_Init(99,7199)前，不然会白屏。  </p><p>完结。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 这是大二暑假学习STM32时写的一篇的教程，当初移植的时候耗费了好大的力气，集齐了万千网友的智慧和教程，归纳总结整理出来的，在此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="UCGUI" scheme="https://lxzzzzzxl.github.io/categories/UCGUI/"/>
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/categories/UCGUI/STM32/"/>
    
    
      <category term="STM32" scheme="https://lxzzzzzxl.github.io/tags/STM32/"/>
    
      <category term="UCGUI" scheme="https://lxzzzzzxl.github.io/tags/UCGUI/"/>
    
  </entry>
  
</feed>
